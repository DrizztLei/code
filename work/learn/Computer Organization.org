* 指令系统
* 指令
* 操作码 地址码
* 前序
1.长度固定 -> IBM 370 RISC 操作码 8
2.长度可变 -> 操作码分散在指令字的不同字段中
3.拓展操作码技术 -> you know the important .
* 地址码
** 1.四地址(A1) OP (A2) -> A3
A4 for the next order.
access the memory four times.
** 三地址 (A1) OP (A2) -> A3
** 二地址 (A1) OP (A2) -> A1 OR A2 access the memory three
times.
** 一地址 (ACC) OP (A1) -> A1 access the memory two times .
** 零地址 踏空等.
* 指令字长
** 指令字长固定
指令字长 = 存储字长
** 指令字长可变
按照字节的倍数变化
* 操作数类型和操作种类
** 地址 数字 字符 逻辑数
** 数据存储的方式
字地址为低字节地址 or 高字节地址
** 存储器中数据的存放
边界对准和边界不对准
** 操作类型
*** 数据传送
MOVE STORE PUSH LOAD MOVE POP
*** 算数逻辑操作
+ - * / ++ -- ~ float-compute compute-d
*** 移位操作
算数移位 和 逻辑移位 还有 循环移位 ( 带有 进位 和 不带
进位 )
*** 转移
**** 无条件转移 JMP
**** 条件转移 C V N Z ( 0 标志位 ) O ( 溢出位 ) SKP
example :SKP DZ D=0 (
*** 调用和返回
*** 陷阱 (Trap) 和 陷阱指令 // 意外事故的中断
**** 一般不给用户提供 ， 出现的时候使用CPU的隐指令
*** 输入输出
**  寻址方式
*** 指令寻址
顺序 (PC) + 1 -> PC
跳跃 由转移指令给出
*** 数据寻址
操作码 寻址特征 形式地址A
形式地址 有效地址
约定 指令字长 = 存储字长 = 机器字长
**** 立即寻址
形式地址A 就是操作数
OP # A
这样指令阶段不访存
A的位数限制了立即数的范围 ， 他是补码 。
**** 直接寻址
EA = A 有效地址 由 形式地址 给出。
LDA [EMPTY] A -> A 操作数 ( ACC )
执行阶段访问一次存储器
限制的是存储器的访问空间 -> 寻址范围
操作数的地址不易修改
**** 隐含寻址
操作数 地址 在 操作码 中
ADD [type of searching] A
此时另一个数字在ACC中
指令字中少了一个地址字段，可以缩短指令字长
**** 间接寻址
EA = (A)
执行指令阶段两次访存
扩大寻址范围
JMP @A ; @的含义是间址特征
**** 寄存器寻址
EA = Ri ;有效地址就是寄存器编号
执行速度快 ， 不用访问内存
寄存器少，可以用来缩短指令字长
**** 寄存器间接寻址
EA = (Ri)
有利于编制循环体系的程序
**** 基址寻址
***** 使用专用寄存器寻址 EA = (BR) + A ; BR 为基址寄存器
值得注意的是 ， 中间需要使用ALU 就是运算逻辑单元来进行
运算出主存中EA的位置
可以扩大寻址范围 ， 多道程序的使用 ， BR 内容由操作系
统或者管理程序确定 。BR 不变， 但是 A 可以变的。
***** 采用通用寄存器当作基址寄存器
就是相当于指定某个寄存器。可以由用户确定。R0基址寄存器
的内容还是系统确定。并且不变，可变的是A。
**** 变址寻址
在变址寻址中，通用寄存器的值由用户指定，这个是和寄存器
寻址不一样的地方。
such as : EA = (IX) + A ; IX 变址寄存器(专用)
通用寄存器也可以作为变址寄存器。
这个时候A不可以改变。
这个可以用来处理数组问题。
example :
直接寻址
LDA D
ADD D + 1
ADD D + 1
...
ADD + ( N - 1 )
DIV #N
STA ANS
变址寻址
LDA # 0
LDX # 0
ADD X , D
INX
CPX #N
BNE M
DEV #N
STA ANS
**** 相对寻址
EA = ( PC ) + A
A 是位移量 可以是正的也可以是负的。
程序会浮动
广泛用于转移指令
相对寻址 举例
*****
2000H 8 -> 2008H 8
这个时候我们知道取指令到2001H 的时候 ， PC = 2002
JMP * + 8 所以 JMP * + 8指令的第二字节为 06H
**** 堆栈寻址
硬堆栈 -> 多个寄存器
软堆栈 -> 指定的存储空间
SP 的修改和主存的编址方法有关
却绝于是按字编制还是按照字节编制
* 指令格式举例
** 系统的兼容性
** 操作类型 数据类型 指令格式 寻址方式 ..
指令个数 操作的难易程度 参与运算的数据类型 指令字长是否固定
是否采用操作码拓展技术 寻址方式等 寄存器的个数
* RISC 技术
** 使用简单的指令的组合逻辑来实现剩下的功能。
** 只有 LOAD/STORE指令访存  CPU由多个通用寄存器 指令长度固定 种类格式少 寻址方式少 使用简单的指令的组合逻辑来实现剩下的功能
使用流水技术 一个时钟周期完成一个指令 采用优化的编译程序
CISC 难以使用优化编译成成高效的目标代码
** RISC 可以更充分 利用 VLSI 芯片面积 提高运算性能 成本低 易于实现 不容易实现指令系统兼容
* CPU的 结构
** 功能
*** 控制器的功能
取指令 分析指令 执行指令 发出各种操作命令 总线管理 异常
等处理 控制程序的输入以及结果的输出
*** 运算器的功能
实现算数运算和逻辑运算
** CPU的 结构图
指令控制 PC IR
操作控制
时间控制 CU 时序电路
数据加工 ALU寄存器
ALU 状态位 取反 标志位 算术逻辑 内部CPU数据总线 寄存器 CU 系
统中断 控制信号
** CPU 的 寄存器
*** 用户可见寄存器
通用寄存器            数据寄存器            地址寄存器           条件码寄存器
操作数              操作数 满足各种数据类型   存放地址             存放条件码
可做专用寄存器         双倍字长数据           特殊寻址            条件分支的依据
*** 控制 寄存器
PC -> MAR -> M -> MDR -> IR
MAR IR MDR 用户不可见
*** 状态寄存器
状态寄存器 存放条件码
PSW寄存器 存放程序状态字
** 控制单元 CU 和 中断系统
*** CU 产生全部指令的微操作命令序列
** 指令周期
取出并且完成一条指令所需要的全部时间
取指 分析 称为取指周期
执行 称为执行周期
每条指令的指令周期不同
NOP指令中 取指周期就是指令周期 ， 因为执行周期为0 。
MUL 貌似由若干个执行周期
*** 具有间接寻址 的指令周期
它的指令周期中还有一个间址周期
*** 具有中断周期的指令系统
取指 间址 执行 中断
一共四个周期 称作一个指令周期
** CPU工作的周期的标志
CPU 访存的四种性质
取指令->取指周期
取地址->间址周期
取操作数->执行周期
存程序断点->中断周期
CPU的4个工作周期
** 指令周期的数据流
PC -> MAR
(PC) + 1 -> PC
( MAR ) -> MDR
( MDR ) -> IR
*** 因素
人为因素 -> 转管指令等 。
程序事故
硬件故障
I/0设备
外部设备 键盘中断
** 中断请求标记和判优逻辑
*** INTR 中断请求标记
多个 INTR 标记组成了中断请求标记寄存器
INTR 分散在各个中断源的接口电路中。
INTR 集中在CPU的中断系统内部
** 中断判优逻辑
*** 排队器 ( 硬件实现 )
分散 -> 链式排队器
集中 -> CPU
*** 软件实现
    实际就是中断判优
