This is ../../info/emacs, produced by makeinfo version 4.11 from
emacs.texi.

This is the Sixteenth edition of the `GNU Emacs Manual',
updated for Emacs version 23.2.

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


File: emacs,  Node: Recognize Coding,  Next: Specify Coding,  Prev: Coding Systems,  Up: International

26.7 Recognizing Coding Systems
===============================

Whenever Emacs reads a given piece of text, it tries to recognize which
coding system to use.  This applies to files being read, output from
subprocesses, text from X selections, etc.  Emacs can select the right
coding system automatically most of the time--once you have specified
your preferences.

   Some coding systems can be recognized or distinguished by which byte
sequences appear in the data.  However, there are coding systems that
cannot be distinguished, not even potentially.  For example, there is no
way to distinguish between Latin-1 and Latin-2; they use the same byte
values with different meanings.

   Emacs handles this situation by means of a priority list of coding
systems.  Whenever Emacs reads a file, if you do not specify the coding
system to use, Emacs checks the data against each coding system,
starting with the first in priority and working down the list, until it
finds a coding system that fits the data.  Then it converts the file
contents assuming that they are represented in this coding system.

   The priority list of coding systems depends on the selected language
environment (*note Language Environments::).  For example, if you use
French, you probably want Emacs to prefer Latin-1 to Latin-2; if you use
Czech, you probably want Latin-2 to be preferred.  This is one of the
reasons to specify a language environment.

   However, you can alter the coding system priority list in detail
with the command `M-x prefer-coding-system'.  This command reads the
name of a coding system from the minibuffer, and adds it to the front
of the priority list, so that it is preferred to all others.  If you
use this command several times, each use adds one element to the front
of the priority list.

   If you use a coding system that specifies the end-of-line conversion
type, such as `iso-8859-1-dos', what this means is that Emacs should
attempt to recognize `iso-8859-1' with priority, and should use DOS
end-of-line conversion when it does recognize `iso-8859-1'.

   Sometimes a file name indicates which coding system to use for the
file.  The variable `file-coding-system-alist' specifies this
correspondence.  There is a special function
`modify-coding-system-alist' for adding elements to this list.  For
example, to read and write all `.txt' files using the coding system
`chinese-iso-8bit', you can execute this Lisp expression:

     (modify-coding-system-alist 'file "\\.txt\\'" 'chinese-iso-8bit)

The first argument should be `file', the second argument should be a
regular expression that determines which files this applies to, and the
third argument says which coding system to use for these files.

   Emacs recognizes which kind of end-of-line conversion to use based on
the contents of the file: if it sees only carriage-returns, or only
carriage-return linefeed sequences, then it chooses the end-of-line
conversion accordingly.  You can inhibit the automatic use of
end-of-line conversion by setting the variable `inhibit-eol-conversion'
to non-`nil'.  If you do that, DOS-style files will be displayed with
the `^M' characters visible in the buffer; some people prefer this to
the more subtle `(DOS)' end-of-line type indication near the left edge
of the mode line (*note eol-mnemonic: Mode Line.).

   By default, the automatic detection of coding system is sensitive to
escape sequences.  If Emacs sees a sequence of characters that begin
with an escape character, and the sequence is valid as an ISO-2022
code, that tells Emacs to use one of the ISO-2022 encodings to decode
the file.

   However, there may be cases that you want to read escape sequences
in a file as is.  In such a case, you can set the variable
`inhibit-iso-escape-detection' to non-`nil'.  Then the code detection
ignores any escape sequences, and never uses an ISO-2022 encoding.  The
result is that all escape sequences become visible in the buffer.

   The default value of `inhibit-iso-escape-detection' is `nil'.  We
recommend that you not change it permanently, only for one specific
operation.  That's because many Emacs Lisp source files in the Emacs
distribution contain non-ASCII characters encoded in the coding system
`iso-2022-7bit', and they won't be decoded correctly when you visit
those files if you suppress the escape sequence detection.

   The variables `auto-coding-alist', `auto-coding-regexp-alist' and
`auto-coding-functions' are the strongest way to specify the coding
system for certain patterns of file names, or for files containing
certain patterns; these variables even override `-*-coding:-*-' tags in
the file itself.  Emacs uses `auto-coding-alist' for tar and archive
files, to prevent it from being confused by a `-*-coding:-*-' tag in a
member of the archive and thinking it applies to the archive file as a
whole.  Likewise, Emacs uses `auto-coding-regexp-alist' to ensure that
RMAIL files, whose names in general don't match any particular pattern,
are decoded correctly.  One of the builtin `auto-coding-functions'
detects the encoding for XML files.

   When you get new mail in Rmail, each message is translated
automatically from the coding system it is written in, as if it were a
separate file.  This uses the priority list of coding systems that you
have specified.  If a MIME message specifies a character set, Rmail
obeys that specification, unless `rmail-decode-mime-charset' is `nil'.
For reading and saving Rmail files themselves, Emacs uses the coding
system specified by the variable `rmail-file-coding-system'.  The
default value is `nil', which means that Rmail files are not translated
(they are read and written in the Emacs internal character code).


File: emacs,  Node: Specify Coding,  Next: Output Coding,  Prev: Recognize Coding,  Up: International

26.8 Specifying a File's Coding System
======================================

If Emacs recognizes the encoding of a file incorrectly, you can reread
the file using the correct coding system by typing `C-x <RET> r
CODING-SYSTEM <RET>'.  To see what coding system Emacs actually used to
decode the file, look at the coding system mnemonic letter near the
left edge of the mode line (*note Mode Line::), or type `C-h C <RET>'.

   You can specify the coding system for a particular file in the file
itself, using the `-*-...-*-' construct at the beginning, or a local
variables list at the end (*note File Variables::).  You do this by
defining a value for the "variable" named `coding'.  Emacs does not
really have a variable `coding'; instead of setting a variable, this
uses the specified coding system for the file.  For example, `-*-mode:
C; coding: latin-1;-*-' specifies use of the Latin-1 coding system, as
well as C mode.  When you specify the coding explicitly in the file,
that overrides `file-coding-system-alist'.


File: emacs,  Node: Output Coding,  Next: Text Coding,  Prev: Specify Coding,  Up: International

26.9 Choosing Coding Systems for Output
=======================================

Once Emacs has chosen a coding system for a buffer, it stores that
coding system in `buffer-file-coding-system'.  That makes it the
default for operations that write from this buffer into a file, such as
`save-buffer' and `write-region'.  You can specify a different coding
system for further file output from the buffer using
`set-buffer-file-coding-system' (*note Text Coding::).

   You can insert any character Emacs supports into any Emacs buffer,
but most coding systems can only handle a subset of these characters.
Therefore, it's possible that the characters you insert cannot be
encoded with the coding system that will be used to save the buffer.
For example, you could visit a text file in Polish, encoded in
`iso-8859-2', and add some Russian words to it.  When you save that
buffer, Emacs cannot use the current value of
`buffer-file-coding-system', because the characters you added cannot be
encoded by that coding system.

   When that happens, Emacs tries the most-preferred coding system (set
by `M-x prefer-coding-system' or `M-x set-language-environment').  If
that coding system can safely encode all of the characters in the
buffer, Emacs uses it, and stores its value in
`buffer-file-coding-system'.  Otherwise, Emacs displays a list of
coding systems suitable for encoding the buffer's contents, and asks
you to choose one of those coding systems.

   If you insert the unsuitable characters in a mail message, Emacs
behaves a bit differently.  It additionally checks whether the
most-preferred coding system is recommended for use in MIME messages;
if not, Emacs tells you that the most-preferred coding system is not
recommended and prompts you for another coding system.  This is so you
won't inadvertently send a message encoded in a way that your
recipient's mail software will have difficulty decoding.  (You can
still use an unsuitable coding system if you type its name in response
to the question.)

   When you send a message with Message mode (*note Sending Mail::),
Emacs has four different ways to determine the coding system to use for
encoding the message text.  It tries the buffer's own value of
`buffer-file-coding-system', if that is non-`nil'.  Otherwise, it uses
the value of `sendmail-coding-system', if that is non-`nil'.  The third
way is to use the default coding system for new files, which is
controlled by your choice of language environment, if that is
non-`nil'.  If all of these three values are `nil', Emacs encodes
outgoing mail using the Latin-1 coding system.


File: emacs,  Node: Text Coding,  Next: Communication Coding,  Prev: Output Coding,  Up: International

26.10 Specifying a Coding System for File Text
==============================================

In cases where Emacs does not automatically choose the right coding
system for a file's contents, you can use these commands to specify one:

`C-x <RET> f CODING <RET>'
     Use coding system CODING for saving or revisiting the visited file
     in the current buffer.

`C-x <RET> c CODING <RET>'
     Specify coding system CODING for the immediately following command.

`C-x <RET> r CODING <RET>'
     Revisit the current file using the coding system CODING.

`M-x recode-region <RET> RIGHT <RET> WRONG <RET>'
     Convert a region that was decoded using coding system WRONG,
     decoding it using coding system RIGHT instead.

   The command `C-x <RET> f' (`set-buffer-file-coding-system') sets the
file coding system for the current buffer--in other words, it says
which coding system to use when saving or reverting the visited file.
You specify which coding system using the minibuffer.  If you specify a
coding system that cannot handle all of the characters in the buffer,
Emacs warns you about the troublesome characters when you actually save
the buffer.

   You can also use this command to specify the end-of-line conversion
(*note end-of-line conversion: Coding Systems.) for encoding the
current buffer.  For example, `C-x <RET> f dos <RET>' will cause Emacs
to save the current buffer's text with DOS-style CRLF line endings.

   Another way to specify the coding system for a file is when you visit
the file.  First use the command `C-x <RET> c'
(`universal-coding-system-argument'); this command uses the minibuffer
to read a coding system name.  After you exit the minibuffer, the
specified coding system is used for _the immediately following command_.

   So if the immediately following command is `C-x C-f', for example,
it reads the file using that coding system (and records the coding
system for when you later save the file).  Or if the immediately
following command is `C-x C-w', it writes the file using that coding
system.  When you specify the coding system for saving in this way,
instead of with `C-x <RET> f', there is no warning if the buffer
contains characters that the coding system cannot handle.

   Other file commands affected by a specified coding system include
`C-x i' and `C-x C-v', as well as the other-window variants of `C-x
C-f'.  `C-x <RET> c' also affects commands that start subprocesses,
including `M-x shell' (*note Shell::).  If the immediately following
command does not use the coding system, then `C-x <RET> c' ultimately
has no effect.

   An easy way to visit a file with no conversion is with the `M-x
find-file-literally' command.  *Note Visiting::.

   The default value of the variable `buffer-file-coding-system'
specifies the choice of coding system to use when you create a new file.
It applies when you find a new file, and when you create a buffer and
then save it in a file.  Selecting a language environment typically sets
this variable to a good choice of default coding system for that
language environment.

   If you visit a file with a wrong coding system, you can correct this
with `C-x <RET> r' (`revert-buffer-with-coding-system').  This visits
the current file again, using a coding system you specify.

   If a piece of text has already been inserted into a buffer using the
wrong coding system, you can redo the decoding of it using `M-x
recode-region'.  This prompts you for the proper coding system, then
for the wrong coding system that was actually used, and does the
conversion.  It first encodes the region using the wrong coding system,
then decodes it again using the proper coding system.


File: emacs,  Node: Communication Coding,  Next: File Name Coding,  Prev: Text Coding,  Up: International

26.11 Coding Systems for Interprocess Communication
===================================================

This section explains how to specify coding systems for use in
communication with other processes.

`C-x <RET> x CODING <RET>'
     Use coding system CODING for transferring selections to and from
     other window-based applications.

`C-x <RET> X CODING <RET>'
     Use coding system CODING for transferring _one_ selection--the
     next one--to or from another window-based application.

`C-x <RET> p INPUT-CODING <RET> OUTPUT-CODING <RET>'
     Use coding systems INPUT-CODING and OUTPUT-CODING for subprocess
     input and output in the current buffer.

`C-x <RET> c CODING <RET>'
     Specify coding system CODING for the immediately following command.

   The command `C-x <RET> x' (`set-selection-coding-system') specifies
the coding system for sending selected text to other windowing
applications, and for receiving the text of selections made in other
applications.  This command applies to all subsequent selections, until
you override it by using the command again.  The command `C-x <RET> X'
(`set-next-selection-coding-system') specifies the coding system for
the next selection made in Emacs or read by Emacs.

   The variable `x-select-request-type' specifies the data type to
request from the X Window System for receiving text selections from
other applications.  If the value is `nil' (the default), Emacs tries
`COMPOUND_TEXT' and `UTF8_STRING', in this order, and uses various
heuristics to choose the more appropriate of the two results; if none
of these succeed, Emacs falls back on `STRING'.  If the value of
`x-select-request-type' is one of the symbols `COMPOUND_TEXT',
`UTF8_STRING', `STRING', or `TEXT', Emacs uses only that request type.
If the value is a list of some of these symbols, Emacs tries only the
request types in the list, in order, until one of them succeeds, or
until the list is exhausted.

   The command `C-x <RET> p' (`set-buffer-process-coding-system')
specifies the coding system for input and output to a subprocess.  This
command applies to the current buffer; normally, each subprocess has its
own buffer, and thus you can use this command to specify translation to
and from a particular subprocess by giving the command in the
corresponding buffer.

   You can also use `C-x <RET> c' just before the command that runs or
starts a subprocess, to specify the coding system to use for
communication with that subprocess.

   The default for translation of process input and output depends on
the current language environment.

   The variable `locale-coding-system' specifies a coding system to use
when encoding and decoding system strings such as system error messages
and `format-time-string' formats and time stamps.  That coding system
is also used for decoding non-ASCII keyboard input on X Window systems.
You should choose a coding system that is compatible with the
underlying system's text representation, which is normally specified by
one of the environment variables `LC_ALL', `LC_CTYPE', and `LANG'.
(The first one, in the order specified above, whose value is nonempty
is the one that determines the text representation.)

   The variable `x-select-request-type' specifies a selection data type
of selection to request from the X server.  The default value is `nil',
which means Emacs tries `COMPOUND_TEXT' and `UTF8_STRING', and uses
whichever result seems more appropriate.  You can explicitly specify
the data type by setting the variable to one of the symbols
`COMPOUND_TEXT', `UTF8_STRING', `STRING' and `TEXT'.


File: emacs,  Node: File Name Coding,  Next: Terminal Coding,  Prev: Communication Coding,  Up: International

26.12 Coding Systems for File Names
===================================

`C-x <RET> F CODING <RET>'
     Use coding system CODING for encoding and decoding file _names_.

   The variable `file-name-coding-system' specifies a coding system to
use for encoding file names.  It has no effect on reading and writing
the _contents_ of files.

   If you set the variable to a coding system name (as a Lisp symbol or
a string), Emacs encodes file names using that coding system for all
file operations.  This makes it possible to use non-ASCII characters in
file names--or, at least, those non-ASCII characters which the
specified coding system can encode.  Use `C-x <RET> F'
(`set-file-name-coding-system') to specify this interactively.

   If `file-name-coding-system' is `nil', Emacs uses a default coding
system determined by the selected language environment.  In the default
language environment, non-ASCII characters in file names are not
encoded specially; they appear in the file system using the internal
Emacs representation.

   *Warning:* if you change `file-name-coding-system' (or the language
environment) in the middle of an Emacs session, problems can result if
you have already visited files whose names were encoded using the
earlier coding system and cannot be encoded (or are encoded
differently) under the new coding system.  If you try to save one of
these buffers under the visited file name, saving may use the wrong file
name, or it may get an error.  If such a problem happens, use `C-x C-w'
to specify a new file name for that buffer.

   If a mistake occurs when encoding a file name, use the command `M-x
recode-file-name' to change the file name's coding system.  This
prompts for an existing file name, its old coding system, and the
coding system to which you wish to convert.


File: emacs,  Node: Terminal Coding,  Next: Fontsets,  Prev: File Name Coding,  Up: International

26.13 Coding Systems for Terminal I/O
=====================================

`C-x <RET> k CODING <RET>'
     Use coding system CODING for keyboard input.

`C-x <RET> t CODING <RET>'
     Use coding system CODING for terminal output.

   The command `C-x <RET> t' (`set-terminal-coding-system') specifies
the coding system for terminal output.  If you specify a character code
for terminal output, all characters output to the terminal are
translated into that coding system.

   This feature is useful for certain character-only terminals built to
support specific languages or character sets--for example, European
terminals that support one of the ISO Latin character sets.  You need to
specify the terminal coding system when using multibyte text, so that
Emacs knows which characters the terminal can actually handle.

   By default, output to the terminal is not translated at all, unless
Emacs can deduce the proper coding system from your terminal type or
your locale specification (*note Language Environments::).

   The command `C-x <RET> k' (`set-keyboard-coding-system') or the
variable `keyboard-coding-system' specifies the coding system for
keyboard input.  Character-code translation of keyboard input is useful
for terminals with keys that send non-ASCII graphic characters--for
example, some terminals designed for ISO Latin-1 or subsets of it.

   By default, keyboard input is translated based on your system locale
setting.  If your terminal does not really support the encoding implied
by your locale (for example, if you find it inserts a non-ASCII
character if you type `M-i'), you will need to set
`keyboard-coding-system' to `nil' to turn off encoding.  You can do
this by putting

     (set-keyboard-coding-system nil)

in your init file.

   There is a similarity between using a coding system translation for
keyboard input, and using an input method: both define sequences of
keyboard input that translate into single characters.  However, input
methods are designed to be convenient for interactive use by humans, and
the sequences that are translated are typically sequences of ASCII
printing characters.  Coding systems typically translate sequences of
non-graphic characters.


File: emacs,  Node: Fontsets,  Next: Defining Fontsets,  Prev: Terminal Coding,  Up: International

26.14 Fontsets
==============

A font typically defines shapes for a single alphabet or script.
Therefore, displaying the entire range of scripts that Emacs supports
requires a collection of many fonts.  In Emacs, such a collection is
called a "fontset".  A fontset is defined by a list of font specs, each
assigned to handle a range of character codes, and may fall back on
another fontset for characters which are not covered by the fonts it
specifies.

   Each fontset has a name, like a font.  However, while fonts are
stored in the system and the available font names are defined by the
system, fontsets are defined within Emacs itself.  Once you have
defined a fontset, you can use it within Emacs by specifying its name,
anywhere that you could use a single font.  Of course, Emacs fontsets
can use only the fonts that the system supports; if certain characters
appear on the screen as hollow boxes, this means that the fontset in
use for them has no font for those characters.(1)

   Emacs creates three fontsets automatically: the "standard fontset",
the "startup fontset" and the "default fontset".  The default fontset
is most likely to have fonts for a wide variety of non-ASCII characters
and is the default fallback for the other two fontsets, and if you set
a default font rather than fontset.  However it does not specify font
family names, so results can be somewhat random if you use it directly.
You can specify use of a specific fontset with the `-fn' option.  For
example,

     emacs -fn fontset-standard

You can also specify a fontset with the `Font' resource (*note X
Resources::).

   If no fontset is specified for use, then Emacs uses an ASCII font,
with `fontset-default' as a fallback for characters the font does not
cover.  The standard fontset is only used if explicitly requested,
despite its name.

   A fontset does not necessarily specify a font for every character
code.  If a fontset specifies no font for a certain character, or if it
specifies a font that does not exist on your system, then it cannot
display that character properly.  It will display that character as an
empty box instead.

   ---------- Footnotes ----------

   (1) The Emacs installation instructions have information on
additional font support.


File: emacs,  Node: Defining Fontsets,  Next: Modifying Fontsets,  Prev: Fontsets,  Up: International

26.15 Defining fontsets
=======================

When running on X, Emacs creates a standard fontset automatically
according to the value of `standard-fontset-spec'.  This fontset's name
is

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

or just `fontset-standard' for short.

   On GNUstep and Mac, fontset-standard is created using the value of
`ns-standard-fontset-spec', and on Windows it is created using the
value of `w32-standard-fontset-spec'.

   Bold, italic, and bold-italic variants of the standard fontset are
created automatically.  Their names have `bold' instead of `medium', or
`i' instead of `r', or both.

   Emacs generates a fontset automatically, based on any default ASCII
font that you specify with the `Font' resource or the `-fn' argument,
or the default font that Emacs found when it started.  This is the
"startup fontset" and its name is `fontset-startup'.  It does this by
replacing the CHARSET_REGISTRY field with `fontset', and replacing
CHARSET_ENCODING field with `startup', then using the resulting string
to specify a fontset.

   For instance, if you start Emacs this way,

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacs generates the following fontset and uses it for the initial X
window frame:

     -*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

   The startup fontset will use the font that you specify or a variant
with a different registry and encoding for all the characters which are
supported by that font, and fallback on `fontset-default' for other
characters.

   With the X resource `Emacs.Font', you can specify a fontset name
just like an actual font name.  But be careful not to specify a fontset
name in a wildcard resource like `Emacs*Font'--that wildcard
specification matches various other resources, such as for menus, and
menus cannot handle fontsets.

   You can specify additional fontsets using X resources named
`Fontset-N', where N is an integer starting from 0.  The resource value
should have this form:

     FONTPATTERN, [CHARSET:FONT]...

FONTPATTERN should have the form of a standard X font name, except for
the last two fields.  They should have the form `fontset-ALIAS'.

   The fontset has two names, one long and one short.  The long name is
FONTPATTERN.  The short name is `fontset-ALIAS'.  You can refer to the
fontset by either name.

   The construct `CHARSET:FONT' specifies which font to use (in this
fontset) for one particular character set.  Here, CHARSET is the name
of a character set, and FONT is the font to use for that character set.
You can use this construct any number of times in defining one fontset.

   For the other character sets, Emacs chooses a font based on
FONTPATTERN.  It replaces `fontset-ALIAS' with values that describe the
character set.  For the ASCII character font, `fontset-ALIAS' is
replaced with `ISO8859-1'.

   In addition, when several consecutive fields are wildcards, Emacs
collapses them into a single wildcard.  This is to prevent use of
auto-scaled fonts.  Fonts made by scaling larger fonts are not usable
for editing, and scaling a smaller font is not useful because it is
better to use the smaller font in its own size, which is what Emacs
does.

   Thus if FONTPATTERN is this,

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

the font specification for ASCII characters would be this:

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

and the font specification for Chinese GB2312 characters would be this:

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

   You may not have any Chinese font matching the above font
specification.  Most X distributions include only Chinese fonts that
have `song ti' or `fangsong ti' in FAMILY field.  In such a case,
`Fontset-N' can be specified as below:

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

Then, the font specifications for all but Chinese GB2312 characters have
`fixed' in the FAMILY field, and the font specification for Chinese
GB2312 characters has a wild card `*' in the FAMILY field.

   The function that processes the fontset resource value to create the
fontset is called `create-fontset-from-fontset-spec'.  You can also
call this function explicitly to create a fontset.

   *Note Fonts::, for more information about font naming.


File: emacs,  Node: Modifying Fontsets,  Next: Undisplayable Characters,  Prev: Defining Fontsets,  Up: International

26.16 Modifying Fontsets
========================

Fontsets do not always have to be created from scratch.  If only minor
changes are required it may be easier to modify an existing fontset.
Modifying `fontset-default' will also affect other fontsets that use it
as a fallback, so can be an effective way of fixing problems with the
fonts that Emacs chooses for a particular script.

   Fontsets can be modified using the function `set-fontset-font',
specifying a character, a charset, a script, or a range of characters
to modify the font for, and a font-spec for the font to be used. Some
examples are:

     ;; Use Liberation Mono for latin-3 charset.
     (set-fontset-font "fontset-default" 'iso-8859-3 "Liberation Mono")

     ;; Prefer a big5 font for han characters
     (set-fontset-font "fontset-default" 'han (font-spec :registry "big5")
                       nil 'prepend)

     ;; Use DejaVu Sans Mono as a fallback in fontset-startup before
     ;; resorting to fontset-default.
     (set-fontset-font "fontset-startup" nil "DejaVu Sans Mono" nil 'append)

     ;; Use MyPrivateFont for the Unicode private use area.
     (set-fontset-font "fontset-default"  '(#xe000 . #xf8ff) "MyPrivateFont")


File: emacs,  Node: Undisplayable Characters,  Next: Unibyte Mode,  Prev: Modifying Fontsets,  Up: International

26.17 Undisplayable Characters
==============================

There may be a some non-ASCII characters that your terminal cannot
display.  Most text-only terminals support just a single character set
(use the variable `default-terminal-coding-system' (*note Terminal
Coding::) to tell Emacs which one); characters which can't be encoded
in that coding system are displayed as `?' by default.

   Graphical displays can display a broader range of characters, but
you may not have fonts installed for all of them; characters that have
no font appear as a hollow box.

   If you use Latin-1 characters but your terminal can't display
Latin-1, you can arrange to display mnemonic ASCII sequences instead,
e.g. `"o' for o-umlaut.  Load the library `iso-ascii' to do this.

   If your terminal can display Latin-1, you can display characters
from other European character sets using a mixture of equivalent
Latin-1 characters and ASCII mnemonics.  Customize the variable
`latin1-display' to enable this.  The mnemonic ASCII sequences mostly
correspond to those of the prefix input methods.


File: emacs,  Node: Unibyte Mode,  Next: Charsets,  Prev: Undisplayable Characters,  Up: International

26.18 Unibyte Editing Mode
==========================

The ISO 8859 Latin-N character sets define character codes in the range
0240 to 0377 octal (160 to 255 decimal) to handle the accented letters
and punctuation needed by various European languages (and some
non-European ones).  Note that Emacs considers bytes with codes in this
range as raw bytes, not as characters, even in a unibyte session, i.e.
if you disable multibyte characters.  However, Emacs can still handle
these character codes as if they belonged to _one_ of the single-byte
character sets at a time.  To specify _which_ of these codes to use,
invoke `M-x set-language-environment' and specify a suitable language
environment such as `Latin-N'.

   For more information about unibyte operation, see *note Enabling
Multibyte::.  Note particularly that you probably want to ensure that
your initialization files are read as unibyte if they contain non-ASCII
characters.

   Emacs can also display bytes in the range 160 to 255 as readable
characters, provided the terminal or font in use supports them.  This
works automatically.  On a graphical display, Emacs can also display
single-byte characters through fontsets, in effect by displaying the
equivalent multibyte characters according to the current language
environment.  To request this, set the variable
`unibyte-display-via-language-environment' to a non-`nil' value.  Note
that setting this only affects how these bytes are displayed, but does
not change the fundamental fact that Emacs treats them as raw bytes,
not as characters.

   If your terminal does not support display of the Latin-1 character
set, Emacs can display these characters as ASCII sequences which at
least give you a clear idea of what the characters are.  To do this,
load the library `iso-ascii'.  Similar libraries for other Latin-N
character sets could be implemented, but we don't have them yet.

   Normally non-ISO-8859 characters (decimal codes between 128 and 159
inclusive) are displayed as octal escapes.  You can change this for
non-standard "extended" versions of ISO-8859 character sets by using the
function `standard-display-8bit' in the `disp-table' library.

   There are two ways to input single-byte non-ASCII characters:

   * You can use an input method for the selected language environment.
     *Note Input Methods::.  When you use an input method in a unibyte
     buffer, the non-ASCII character you specify with it is converted
     to unibyte.

   * If your keyboard can generate character codes 128 (decimal) and up,
     representing non-ASCII characters, you can type those character
     codes directly.

     On a graphical display, you should not need to do anything special
     to use these keys; they should simply work.  On a text-only
     terminal, you should use the command `M-x
     set-keyboard-coding-system' or the variable
     `keyboard-coding-system' to specify which coding system your
     keyboard uses (*note Terminal Coding::).  Enabling this feature
     will probably require you to use `ESC' to type Meta characters;
     however, on a console terminal or in `xterm', you can arrange for
     Meta to be converted to `ESC' and still be able type 8-bit
     characters present directly on the keyboard or using `Compose' or
     `AltGr' keys.  *Note User Input::.

   * For Latin-1 only, you can use the key `C-x 8' as a "compose
     character" prefix for entry of non-ASCII Latin-1 printing
     characters.  `C-x 8' is good for insertion (in the minibuffer as
     well as other buffers), for searching, and in any other context
     where a key sequence is allowed.

     `C-x 8' works by loading the `iso-transl' library.  Once that
     library is loaded, the <ALT> modifier key, if the keyboard has
     one, serves the same purpose as `C-x 8': use <ALT> together with
     an accent character to modify the following letter.  In addition,
     if the keyboard has keys for the Latin-1 "dead accent characters,"
     they too are defined to compose with the following character, once
     `iso-transl' is loaded.

     Use `C-x 8 C-h' to list all the available `C-x 8' translations.


File: emacs,  Node: Charsets,  Prev: Unibyte Mode,  Up: International

26.19 Charsets
==============

In Emacs, "charset" is short for "character set".  Emacs supports most
popular charsets (such as `ascii', `iso-8859-1', `cp1250', `big5', and
`unicode'), in addition to some charsets of its own (such as `emacs',
`unicode-bmp', and `eight-bit').  All supported characters belong to
one or more charsets.

   Emacs normally "does the right thing" with respect to charsets, so
that you don't have to worry about them.  However, it is sometimes
helpful to know some of the underlying details about charsets.

   One example is font selection (*note Fonts::).  Each language
environment (*note Language Environments::) defines a "priority list"
for the various charsets.  When searching for a font, Emacs initially
attempts to find one that can display the highest-priority charsets.
For instance, in the Japanese language environment, the charset
`japanese-jisx0208' has the highest priority, so Emacs tries to use a
font whose `registry' property is `JISX0208.1983-0'.

   There are two commands that can be used to obtain information about
charsets.  The command `M-x list-charset-chars' prompts for a charset
name, and displays all the characters in that character set.  The
command `M-x describe-character-set' prompts for a charset name, and
displays information about that charset, including its internal
representation within Emacs.

   To display a list of all supported charsets, type `M-x
list-character-sets'.  The list gives the names of charsets and
additional information to identity each charset (see
`http://www.itscj.ipsj.or.jp/ISO-IR/' for details).  In this list,
charsets are divided into two categories: "normal charsets" are listed
first, followed by "supplementary charsets".  A supplementary charset
is one that is used to define another charset (as a parent or a
subset), or to provide backward-compatibility for older Emacs versions.

   To find out which charset a character in the buffer belongs to, put
point before it and type `C-u C-x =' (*note International Chars::).


File: emacs,  Node: Major Modes,  Next: Indentation,  Prev: International,  Up: Top

27 Major Modes
**************

Emacs provides many alternative "major modes", each of which customizes
Emacs for editing text of a particular sort.  The major modes are
mutually exclusive, and each buffer has one major mode at any time.
The mode line normally shows the name of the current major mode, in
parentheses (*note Mode Line::).

   The least specialized major mode is called "Fundamental mode".  This
mode has no mode-specific redefinitions or variable settings, so that
each Emacs command behaves in its most general manner, and each user
option variable is in its default state.  For editing text of a
specific type that Emacs knows about, such as Lisp code or English
text, you should switch to the appropriate major mode, such as Lisp
mode or Text mode.

   Selecting a major mode changes the meanings of a few keys to become
more specifically adapted to the language being edited.  The ones that
are changed frequently are <TAB>, <DEL>, and `C-j'.  The prefix key
`C-c' normally contains mode-specific commands.  In addition, the
commands which handle comments use the mode to determine how comments
are to be delimited.  Many major modes redefine the syntactical
properties of characters appearing in the buffer.  *Note Syntax::.

   The major modes fall into three major groups.  The first group
contains modes for normal text, either plain or with mark-up.  It
includes Text mode, HTML mode, SGML mode, TeX mode and Outline mode.
The second group contains modes for specific programming languages.
These include Lisp mode (which has several variants), C mode, Fortran
mode, and others.  The remaining major modes are not intended for use
on users' files; they are used in buffers created for specific purposes
by Emacs, such as Dired mode for buffers made by Dired (*note Dired::),
Message mode for buffers made by `C-x m' (*note Sending Mail::), and
Shell mode for buffers used for communicating with an inferior shell
process (*note Interactive Shell::).

   Most programming-language major modes specify that only blank lines
separate paragraphs.  This is to make the paragraph commands useful.
(*Note Paragraphs::.)  They also cause Auto Fill mode to use the
definition of <TAB> to indent the new lines it creates.  This is
because most lines in a program are usually indented (*note
Indentation::).

* Menu:

* Choosing Modes::     How major modes are specified or chosen.


File: emacs,  Node: Choosing Modes,  Prev: Major Modes,  Up: Major Modes

27.1 How Major Modes are Chosen
===============================

You can select a major mode explicitly for the current buffer, but most
of the time Emacs determines which mode to use based on the file name
or on special text in the file.

   To explicitly select a new major, you use an `M-x' command.  Take
the name of a major mode and add `-mode' to get the name of the command
to select that mode.  Thus, you can enter Lisp mode by executing `M-x
lisp-mode'.

   When you visit a file, Emacs usually chooses the right major mode
automatically.  Normally, it makes the choice based on the file
name--for example, files whose names end in `.c' are normally edited in
C mode--but sometimes it chooses the major mode based on the contents
of the file.  Here is the exact procedure:

   First, Emacs checks whether the file contains a file-local variable
that specifies the major mode.  If so, it uses that major mode,
ignoring all other criteria.  *Note File Variables::.  There are
several methods to specify a major mode using a file-local variable;
the simplest is to put the mode name in the first nonblank line,
preceded and followed by `-*-'.  Other text may appear on the line as
well.  For example,

     ; -*-Lisp-*-

tells Emacs to use Lisp mode.  Note how the semicolon is used to make
Lisp treat this line as a comment.  Alternatively, you could write

     ; -*- mode: Lisp;-*-

The latter format allows you to specify local variables as well, like
this:

     ; -*- mode: Lisp; tab-width: 4; -*-

   Second, Emacs checks whether the file's contents begin with `#!'.
If so, that indicates that the file can serve as an executable shell
command, which works by running an interpreter named on the file's
first line (the rest of the file is used as input to the interpreter).
Therefore, Emacs tries to use the interpreter name to choose a mode.
For instance, a file that begins with `#!/usr/bin/perl' is opened in
Perl mode.  The variable `interpreter-mode-alist' specifies the
correspondence between interpreter program names and major modes.

   When the first line starts with `#!', you usually cannot use the
`-*-' feature on the first line, because the system would get confused
when running the interpreter.  So Emacs looks for `-*-' on the second
line in such files as well as on the first line.  The same is true for
man pages which start with the magic string `'\"' to specify a list of
troff preprocessors.

   Third, Emacs tries to determine the major mode by looking at the
text at the start of the buffer, based on the variable
`magic-mode-alist'.  By default, this variable is `nil' (an empty
list), so Emacs skips this step; however, you can customize it in your
init file (*note Init File::).  The value should be a list of elements
of the form

     (REGEXP . MODE-FUNCTION)

where REGEXP is a regular expression (*note Regexps::), and
MODE-FUNCTION is a Lisp function that toggles a major mode.  If the
text at the beginning of the file matches REGEXP, Emacs chooses the
major mode specified by MODE-FUNCTION.

   Alternatively, an element of `magic-mode-alist' may have the form

     (MATCH-FUNCTION . MODE-FUNCTION)

where MATCH-FUNCTION is a Lisp function that is called at the beginning
of the buffer; if the function returns non-`nil', Emacs set the major
mode wit MODE-FUNCTION.

   Fourth--if Emacs still hasn't found a suitable major mode--it looks
at the file's name.  The correspondence between file names and major
modes is controlled by the variable `auto-mode-alist'.  Its value is a
list in which each element has this form,

     (REGEXP . MODE-FUNCTION)

or this form,

     (REGEXP MODE-FUNCTION FLAG)

For example, one element normally found in the list has the form
`("\\.c\\'" . c-mode)', and it is responsible for selecting C mode for
files whose names end in `.c'.  (Note that `\\' is needed in Lisp
syntax to include a `\' in the string, which must be used to suppress
the special meaning of `.' in regexps.)  If the element has the form
`(REGEXP MODE-FUNCTION FLAG)' and FLAG is non-`nil', then after calling
MODE-FUNCTION, Emacs discards the suffix that matched REGEXP and
searches the list again for another match.

   On systems with case-insensitive file names, such as Microsoft
Windows, Emacs performs a single case-insensitive search through
`auto-mode-alist'.  On other systems, Emacs normally performs a single
case-sensitive search through the alist.  However, if you change the
variable `auto-mode-case-fold' to `t', Emacs performs a second
case-insensitive search if the first search fails.

   Finally, if Emacs _still_ hasn't found a major mode to use, it
compares the text at the start of the buffer to the variable
`magic-fallback-mode-alist'.  This variable works like
`magic-mode-alist', described above, except that is consulted only
after `auto-mode-alist'.  By default, `magic-fallback-mode-alist'
contains forms that check for image files, HTML/XML/SGML files, and
Postscript files.

   Once a major mode is chosen, Emacs sets the value of the variable
`major-mode' to the symbol for that major mode (e.g., `text-mode' for
Text mode).  This is a per-buffer variable (*note Locals::); its
buffer-local value is set automatically, and you should not change it
yourself.

   The default value of `major-mode' determines the major mode to use
for files that do not specify a major mode, and for new buffers created
with `C-x b'.  Normally, this default value is the symbol
`fundamental-mode', which specifies Fundamental mode.  You can change
it via the Customization interface (*note Easy Customization::), or by
adding a line like this to your init file (*note Init File::):

     (setq-default major-mode 'text-mode)

If the default value of `major-mode' is `nil', the major mode is taken
from the previously current buffer.

   If you have changed the major mode of a buffer, you can return to
the major mode Emacs would have chosen automatically, by typing `M-x
normal-mode'.  This is the same function that `find-file' calls to
choose the major mode.  It also processes the file's `-*-' line or
local variables list (if any).  *Note File Variables::.

   The commands `C-x C-w' and `set-visited-file-name' change to a new
major mode if the new file name implies a mode (*note Saving::).  (`C-x
C-s' does this too, if the buffer wasn't visiting a file.)  However,
this does not happen if the buffer contents specify a major mode, and
certain "special" major modes do not allow the mode to change.  You can
turn off this mode-changing feature by setting
`change-major-mode-with-file-name' to `nil'.


File: emacs,  Node: Indentation,  Next: Text,  Prev: Major Modes,  Up: Top

28 Indentation
**************

This chapter describes the Emacs commands that add, remove, or adjust
indentation.

`<TAB>'
     Indent the current line appropriately, in a mode-dependent fashion.

`C-j'
     Perform <RET> followed by <TAB> (`newline-and-indent').

`M-^'
     Merge the previous and the current line (`delete-indentation').
     This would cancel the effect of a preceding `C-j'.

`C-M-o'
     Split the current line at point; text on the line after point
     becomes a new line indented to the same column where point is
     located (`split-line').

`M-m'
     Move (forward or back) to the first nonblank character on the
     current line (`back-to-indentation').

`C-M-\'
     Indent lines in the region to the same column (`indent-region').

`C-x <TAB>'
     Shift lines in the region rigidly right or left (`indent-rigidly').

`M-i'
     Indent from point to the next prespecified tab stop column
     (`tab-to-tab-stop').

`M-x indent-relative'
     Indent from point to under an indentation point in the previous
     line.

The <TAB> key runs `indent-for-tab-command' in most major modes (in C
and related modes, <TAB> runs a separate command,
`c-indent-line-or-region', which behaves similarly).  The major mode
determines just what this entails.

   In text modes, <TAB> inserts some combination of space and tab
characters to advance point to the next tab stop (*note Tab Stops::).
If the region is active and spans multiple lines, it advances the first
character of each of those lines to the next tab stop (*note Using
Region::).  For the purposes of this command, the position of the first
non-whitespace character on the preceding line is treated as an
additional tab stop.  Thus, you can use <TAB> to "align" point with the
preceding line.

   In programming modes, <TAB> adds or removes some combination of
space and tab characters at the start of the line, in a way that makes
sense given the text in the preceding lines.  If the region is active
and spans multiple lines, all those lines are indented this way.  If
point was initially within the current line's indentation, it is
positioned after that indentation; otherwise, it remains at same point
in the newly-indented text.  *Note Program Indent::.

   Normally, indentation commands insert (or remove) an optimal mix of
"tab characters" and spaces to align to the desired column.  Tab
characters (ASCII code 9) are displayed as a stretch of empty space
extending to the next "display tab stop".  By default, there is one
display tab stop every eight columns; the number of columns is
determined by the variable `tab-width'.  You can insert a single tab
character by typing `C-q <TAB>'.  *Note Text Display::.

   The command `M-i' (`tab-to-tab-stop') adjusts the whitespace
characters around point, inserting just enough whitespace to advance
point up to the next tab stop.  By default, this involves deleting the
existing whitespace and inserting a single tab character.

   *Note Just Spaces::, for how to disable use of tabs.  However, `C-q
<TAB>' always inserts a tab, even when tabs are disabled for the
indentation commands.

   The variable `tab-always-indent' tweaks the behavior of the <TAB>
(`indent-for-tab-command') command.  The default value, `t', gives the
behavior described above.  If you change the value to the symbol
`complete', then <TAB> first tries to indent the current line, and if
the line was already indented, it tries to complete the text at point
(*note Symbol Completion::).  If the value is `nil', then <TAB> indents
the current line only if point is at the left margin or in the line's
indentation; otherwise, it inserts a real tab character.

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.


File: emacs,  Node: Indentation Commands,  Next: Tab Stops,  Prev: Indentation,  Up: Indentation

28.1 Indentation Commands and Techniques
========================================

To move over the indentation on a line, do `M-m'
(`back-to-indentation').  This command, given anywhere on a line,
positions point at the first nonblank character on the line, if any, or
else at the end of the line.

   To insert an indented line before the current line, do `C-a C-o
<TAB>'.  To make an indented line after the current line, use `C-e C-j'.

   If you just want to insert a tab character in the buffer, type `C-q
<TAB>'.

   `C-M-o' (`split-line') moves the text from point to the end of the
line vertically down, so that the current line becomes two lines.
`C-M-o' first moves point forward over any spaces and tabs.  Then it
inserts after point a newline and enough indentation to reach the same
column point is on.  Point remains before the inserted newline; in this
regard, `C-M-o' resembles `C-o'.

   To join two lines cleanly, use the `M-^' (`delete-indentation')
command.  It deletes the indentation at the front of the current line,
and the line boundary as well, replacing them with a single space.  As
a special case (useful for Lisp code) the single space is omitted if
the characters to be joined are consecutive open parentheses or closing
parentheses, or if the junction follows another newline.  To delete
just the indentation of a line, go to the beginning of the line and use
`M-\' (`delete-horizontal-space'), which deletes all spaces and tabs
around the cursor.

   If you have a fill prefix, `M-^' deletes the fill prefix if it
appears after the newline that is deleted.  *Note Fill Prefix::.

   There are also commands for changing the indentation of several lines
at once.  They apply to all the lines that begin in the region.
`C-M-\' (`indent-region') indents each line in the "usual" way, as if
you had typed <TAB> at the beginning of the line.  A numeric argument
specifies the column to indent to, and each line is shifted left or
right so that its first nonblank character appears in that column.
`C-x <TAB>' (`indent-rigidly') moves all of the lines in the region
right by its argument (left, for negative arguments).  The whole group
of lines moves rigidly sideways, which is how the command gets its name.

   To remove all indentation from all of the lines in the region,
invoke `C-x <TAB>' with a large negative argument, such as -1000.

   `M-x indent-relative' indents at point based on the previous line
(actually, the last nonempty line).  It inserts whitespace at point,
moving point, until it is underneath the next indentation point in the
previous line.  An indentation point is the end of a sequence of
whitespace or the end of the line.  If point is farther right than any
indentation point in the previous line, `indent-relative' runs
`tab-to-tab-stop' (*note Tab Stops::), unless it is called with a
numeric argument, in which case it does nothing.

   *Note Format Indentation::, for another way of specifying the
indentation for part of your text.


File: emacs,  Node: Tab Stops,  Next: Just Spaces,  Prev: Indentation Commands,  Up: Indentation

28.2 Tab Stops
==============

For typing in tables, you can use `M-i' (`tab-to-tab-stop').  This
command inserts indentation before point, enough to reach the next tab
stop column.

   You can change the tab stops used by `M-i' and other indentation
commands, so that they need not be spaced every eight characters, or
even regularly spaced.  The tab stops are stored in the variable
`tab-stop-list', as a list of column numbers in increasing order.

   A convenient way to set the tab stops is with `M-x edit-tab-stops',
which creates and selects a buffer containing a description of the tab
stop settings.  You can edit this buffer to specify different tab
stops, and then type `C-c C-c' to make those new tab stops take effect.
The buffer uses Overwrite mode (*note Minor Modes::).  `edit-tab-stops'
records which buffer was current when you invoked it, and stores the
tab stops back in that buffer; normally all buffers share the same tab
stops and changing them in one buffer affects all, but if you happen to
make `tab-stop-list' local in one buffer then `edit-tab-stops' in that
buffer will edit the local settings.

   Here is what the text representing the tab stops looks like for
ordinary tab stops every eight columns.

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

   The first line contains a colon at each tab stop.  The remaining
lines are present just to help you see where the colons are and know
what to do.

   Note that the tab stops that control `tab-to-tab-stop' have nothing
to do with how tab characters are displayed in the buffer.  Tab
characters are always displayed as empty spaces extending to the next
display tab stop, which occurs every `tab-width' columns regardless of
the contents of `tab-stop-list'.  *Note Text Display::.


File: emacs,  Node: Just Spaces,  Prev: Tab Stops,  Up: Indentation

28.3 Tabs vs. Spaces
====================

Emacs normally uses both tabs and spaces to indent lines.  If you
prefer, all indentation can be made from spaces only.  To request this,
set `indent-tabs-mode' to `nil'.  This is a per-buffer variable, so
altering the variable affects only the current buffer, but there is a
default value which you can change as well.  *Note Locals::.

   A tab is not always displayed in the same way.  By default, tabs are
eight columns wide, but some people like to customize their editors to
use a different tab width (e.g., by changing the variable `tab-width'
in Emacs).  By using spaces only, you can make sure that your file
looks the same regardless of the tab width setting.

   There are also commands to convert tabs to spaces or vice versa,
always preserving the columns of all nonblank text.  `M-x tabify' scans
the region for sequences of spaces, and converts sequences of at least
two spaces to tabs if that can be done without changing indentation.
`M-x untabify' changes all tabs in the region to appropriate numbers of
spaces.


File: emacs,  Node: Text,  Next: Programs,  Prev: Indentation,  Up: Top

29 Commands for Human Languages
*******************************

This chapter describes Emacs commands that act on "text", by which we
mean sequences of characters in a human language (as opposed to, say, a
computer programming language).  These commands act in ways that take
into account the syntactic and stylistic conventions of human
languages: conventions involving words, sentences, paragraphs, and
capital letters.  There are also commands for "filling", which means
rearranging the lines of a paragraph to be approximately equal in
length.  These commands, while intended primarily for editing text, are
also often useful for editing programs.

   Emacs has several major modes for editing human-language text.  If
the file contains ordinary text, use Text mode, which customizes Emacs
in small ways for the syntactic conventions of text.  Outline mode
provides special commands for operating on text with an outline
structure.

   Emacs has other major modes for text which contains "embedded"
commands, such as TeX and LaTeX (*note TeX Mode::); HTML and SGML
(*note HTML Mode::); XML (*note nXML Mode: (nxml-mode)Top.); and Groff
and Nroff (*note Nroff Mode::).  In addition, you can edit formatted
text in WYSIWYG style ("what you see is what you get"), using Enriched
mode (*note Formatted Text::).

   If you need to edit pictures made out of text characters (commonly
referred to as "ASCII art"), use Picture mode, a special major mode for
editing such pictures.  *Note Picture Mode::.

   The "automatic typing" features may be useful when writing text.
*note (autotype)Top::.

* Menu:

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* HTML Mode::           Editing HTML and SGML files.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.
* Text Based Tables::   Editing text-based tables in WYSIWYG fashion.


File: emacs,  Node: Words,  Next: Sentences,  Up: Text

29.1 Words
==========

Emacs has commands for moving over or operating on words.  By
convention, the keys for them are all Meta characters.

`M-f'
     Move forward over a word (`forward-word').

`M-b'
     Move backward over a word (`backward-word').

`M-d'
     Kill up to the end of a word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of a word (`backward-kill-word').

`M-@'
     Mark the end of the next word (`mark-word').

`M-t'
     Transpose two words or drag a word across others
     (`transpose-words').

   Notice how these keys form a series that parallels the
character-based `C-f', `C-b', `C-d', <DEL> and `C-t'.  `M-@' is cognate
to `C-@', which is an alias for `C-<SPC>'.

   The commands `M-f' (`forward-word') and `M-b' (`backward-word') move
forward and backward over words.  These <Meta>-based key sequences are
analogous to the key sequences `C-f' and `C-b', which move over single
characters.  The analogy extends to numeric arguments, which serve as
repeat counts.  `M-f' with a negative argument moves backward, and
`M-b' with a negative argument moves forward.  Forward motion stops
right after the last letter of the word, while backward motion stops
right before the first letter.

   `M-d' (`kill-word') kills the word after point.  To be precise, it
kills everything from point to the place `M-f' would move to.  Thus, if
point is in the middle of a word, `M-d' kills just the part after
point.  If some punctuation comes between point and the next word, it
is killed along with the word.  (If you wish to kill only the next word
but not the punctuation before it, simply do `M-f' to get the end, and
kill the word backwards with `M-<DEL>'.)  `M-d' takes arguments just
like `M-f'.

   `M-<DEL>' (`backward-kill-word') kills the word before point.  It
kills everything from point back to where `M-b' would move to.  For
instance, if point is after the space in `FOO, BAR', it kills `FOO, '.
If you wish to kill just `FOO', and not the comma and the space, use
`M-b M-d' instead of `M-<DEL>'.

   `M-t' (`transpose-words') exchanges the word before or containing
point with the following word.  The delimiter characters between the
words do not move.  For example, `FOO, BAR' transposes into `BAR, FOO'
rather than `BAR FOO,'.  *Note Transpose::, for more on transposition.

   To operate on the next N words with an operation which acts on the
region, use the command `M-@' (`mark-word').  This command does not
move point, but sets the mark where `M-f' would move to.  Once the mark
is active, each additional `M-@' advances the mark by one additional
word.  `M-@' also accepts a numeric argument that says how many words
to scan for the place to put the mark.

   The word commands' understanding of word boundaries is controlled by
the syntax table.  Any character can, for example, be declared to be a
word delimiter.  *Note Syntax::.


File: emacs,  Node: Sentences,  Next: Paragraphs,  Prev: Words,  Up: Text

29.2 Sentences
==============

The Emacs commands for manipulating sentences and paragraphs are mostly
on Meta keys, so as to be like the word-handling commands.

`M-a'
     Move back to the beginning of the sentence (`backward-sentence').

`M-e'
     Move forward to the end of the sentence (`forward-sentence').

`M-k'
     Kill forward to the end of the sentence (`kill-sentence').

`C-x <DEL>'
     Kill back to the beginning of the sentence
     (`backward-kill-sentence').

   The commands `M-a' and `M-e' (`backward-sentence' and
`forward-sentence') move to the beginning and end of the current
sentence, respectively.  They were chosen to resemble `C-a' and `C-e',
which move to the beginning and end of a line.  Unlike them, `M-a' and
`M-e' move over successive sentences if repeated.

   Moving backward over a sentence places point just before the first
character of the sentence; moving forward places point right after the
punctuation that ends the sentence.  Neither one moves over the
whitespace at the sentence boundary.

   Just as `C-a' and `C-e' have a kill command, `C-k', to go with them,
`M-a' and `M-e' have a corresponding kill command: `M-k'
(`kill-sentence') kills from point to the end of the sentence.  With a
positive numeric argument N, it kills the next N sentences; with a
negative argument -N, it kills back to the beginning of the Nth
preceding sentence.

   The `C-x <DEL>' (`backward-kill-sentence') kills back to the
beginning of a sentence.

   The sentence commands assume that you follow the American typist's
convention of putting two spaces at the end of a sentence; they consider
a sentence to end wherever there is a `.', `?' or `!' followed by the
end of a line or two spaces, with any number of `)', `]', `'', or `"'
characters allowed in between.  A sentence also begins or ends wherever
a paragraph begins or ends.  It is useful to follow this convention,
because it makes a distinction between periods that end a sentence and
periods that indicate abbreviations; that enables the Emacs sentence
commands to distinguish, too.  These commands do not stop for periods
that indicate abbreviations.

   If you want to use just one space between sentences, you can set the
variable `sentence-end-double-space' to `nil' to make the sentence
commands stop for single spaces.  However, this has a drawback: there
is no way to distinguish between periods that end sentences and those
that indicate abbreviations.  For convenient and reliable editing, we
therefore recommend you follow the two-space convention.  The variable
`sentence-end-double-space' also affects filling (*note Fill
Commands::) in related ways.

   The variable `sentence-end' controls how to recognize the end of a
sentence.  If non-`nil', its value should be a regular expression,
which is used to match the last few characters of a sentence, together
with the whitespace following the sentence (*note Regexps::).  If the
value is `nil', the default, then Emacs computes sentence ends
according to various criteria such as the value of
`sentence-end-double-space'.

   Some languages do not use periods to indicate the end of a sentence.
For example, sentences in Thai end with a double space but without a
period.  Set the variable `sentence-end-without-period' to `t' in such
cases.


File: emacs,  Node: Paragraphs,  Next: Pages,  Prev: Sentences,  Up: Text

29.3 Paragraphs
===============

The Emacs commands for manipulating paragraphs are also on Meta keys.

`M-{'
     Move back to previous paragraph beginning (`backward-paragraph').

`M-}'
     Move forward to next paragraph end (`forward-paragraph').

`M-h'
     Put point and mark around this or next paragraph
     (`mark-paragraph').

   `M-{' moves to the beginning of the current or previous paragraph,
while `M-}' moves to the end of the current or next paragraph.  Blank
lines and text-formatter command lines separate paragraphs and are not
considered part of any paragraph.  If there is a blank line before the
paragraph, `M-{' moves to the blank line, because that is convenient in
practice.

   In Text mode, an indented line is not a paragraph break.  If you
want indented lines to have this effect, use Paragraph-Indent Text mode
instead.  *Note Text Mode::.

   In major modes for programs, paragraphs begin and end only at blank
lines.  This makes the paragraph commands useful, even though there are
no paragraphs as such in a program.

   When you have set a fill prefix, then paragraphs are delimited by
all lines which don't start with the fill prefix.  *Note Filling::.

   When you wish to operate on a paragraph, type `M-h'
(`mark-paragraph') to set the region around it.  For example, `M-h C-w'
kills the paragraph around or after point.  `M-h' puts point at the
beginning and mark at the end of the paragraph point was in.  If point
is between paragraphs (in a run of blank lines, or at a boundary), the
paragraph following point is surrounded by point and mark.  If there
are blank lines preceding the first line of the paragraph, one of these
blank lines is included in the region.  If the region is already
active, the command sets the mark without changing point; furthermore,
each subsequent `M-h' further advances the mark by one paragraph.

   The precise definition of a paragraph boundary is controlled by the
variables `paragraph-separate' and `paragraph-start'.  The value of
`paragraph-start' is a regexp that should match any line that either
starts or separates paragraphs.  The value of `paragraph-separate' is
another regexp that should match only lines that separate paragraphs
without being part of any paragraph (for example, blank lines).  Lines
that start a new paragraph and are contained in it must match only
`paragraph-start', not `paragraph-separate'.  Each regular expression
must match at the left margin.  For example, in Fundamental mode,
`paragraph-start' is `"\f\\|[ \t]*$"', and `paragraph-separate' is
`"[ \t\f]*$"'.

   Normally it is desirable for page boundaries to separate paragraphs.
The default values of these variables recognize the usual separator for
pages.


File: emacs,  Node: Pages,  Next: Filling,  Prev: Paragraphs,  Up: Text

29.4 Pages
==========

Within some text files, text is divided into "pages", which are
delimited by the "formfeed character" (ASCII code 12, sometimes denoted
as <control-L>).  When you print hardcopy for a file, the formfeed
character forces a page break: each page of the file goes on a separate
page on paper.  Most Emacs commands treat the formfeed character just
like any other character: you can insert it with `C-q C-l', and delete
it with <DEL>.  However, since pages are often meaningful divisions of
the file, Emacs provides commands to move over them and operate on them.

`C-x ['
     Move point to previous page boundary (`backward-page').

`C-x ]'
     Move point to next page boundary (`forward-page').

`C-x C-p'
     Put point and mark around this page (or another page)
     (`mark-page').

`C-x l'
     Count the lines in this page (`count-lines-page').

   The `C-x [' (`backward-page') command moves point to immediately
after the previous page delimiter.  If point is already right after a
page delimiter, it skips that one and stops at the previous one.  A
numeric argument serves as a repeat count.  The `C-x ]' (`forward-page')
command moves forward past the next page delimiter.

   The `C-x C-p' command (`mark-page') puts point at the beginning of
the current page and the mark at the end.  The page delimiter at the
end is included (the mark follows it).  The page delimiter at the front
is excluded (point follows it).

   `C-x C-p C-w' is a handy way to kill a page to move it elsewhere.
If you move to another page delimiter with `C-x [' and `C-x ]', then
yank the killed page, all the pages will be properly delimited once
again.  The reason `C-x C-p' includes only the following page delimiter
in the region is to ensure that.

   A numeric argument to `C-x C-p' specifies which page to go to,
relative to the current one.  Zero means the current page.  One means
the next page, and -1 means the previous one.

   The `C-x l' command (`count-lines-page') is good for deciding where
to break a page in two.  It displays in the echo area the total number
of lines in the current page, and then divides it up into those
preceding the current line and those following, as in

     Page has 96 (72+25) lines

Notice that the sum is off by one; this is correct if point is not at
the beginning of a line.

   The variable `page-delimiter' controls where pages begin.  Its value
is a regular expression that matches the beginning of a line that
separates pages (*note Regexps::).  The normal value of this variable
is `"^\f"', which matches a formfeed character at the beginning of a
line.


File: emacs,  Node: Filling,  Next: Case,  Prev: Pages,  Up: Text

29.5 Filling Text
=================

"Filling" text means breaking it up into lines that fit a specified
width.  Emacs does filling in two ways.  In Auto Fill mode, inserting
text with self-inserting characters also automatically fills it.  There
are also explicit fill commands that you can use when editing text
leaves it unfilled.  When you edit formatted text, you can specify a
style of filling for each portion of the text (*note Formatted Text::).

* Menu:

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.
* Refill::              Keeping paragraphs filled.
* Longlines::           Editing text with very long lines.


File: emacs,  Node: Auto Fill,  Next: Fill Commands,  Up: Filling

29.5.1 Auto Fill Mode
---------------------

"Auto Fill" mode is a minor mode in which lines are broken
automatically when they become too wide.  Breaking happens only when
you type a <SPC> or <RET>.

`M-x auto-fill-mode'
     Enable or disable Auto Fill mode.

`<SPC>'
`<RET>'
     In Auto Fill mode, break lines when appropriate.

   `M-x auto-fill-mode' turns Auto Fill mode on if it was off, or off
if it was on.  With a positive numeric argument it always turns Auto
Fill mode on, and with a negative argument always turns it off.  You can
see when Auto Fill mode is in effect by the presence of the word `Fill'
in the mode line, inside the parentheses.  Auto Fill mode is a minor
mode which is enabled or disabled for each buffer individually.  *Note
Minor Modes::.

   In Auto Fill mode, lines are broken automatically at spaces when they
get longer than the desired width.  Line breaking and rearrangement
takes place only when you type <SPC> or <RET>.  If you wish to insert a
space or newline without permitting line-breaking, type `C-q <SPC>' or
`C-q C-j' (recall that a newline is really a control-J).  Also, `C-o'
inserts a newline without line breaking.

   Auto Fill mode works well with programming-language modes, because it
indents new lines with <TAB>.  If a line ending in a comment gets too
long, the text of the comment is split into two comment lines.
Optionally, new comment delimiters are inserted at the end of the first
line and the beginning of the second so that each line is a separate
comment; the variable `comment-multi-line' controls the choice (*note
Comments::).

   Adaptive filling (*note Adaptive Fill::) works for Auto Filling as
well as for explicit fill commands.  It takes a fill prefix
automatically from the second or first line of a paragraph.

   Auto Fill mode does not refill entire paragraphs; it can break lines
but cannot merge lines.  So editing in the middle of a paragraph can
result in a paragraph that is not correctly filled.  The easiest way to
make the paragraph properly filled again is usually with the explicit
fill commands.  *Note Fill Commands::.

   Many users like Auto Fill mode and want to use it in all text files.
The section on init files says how to arrange this permanently for
yourself.  *Note Init File::.


File: emacs,  Node: Fill Commands,  Next: Fill Prefix,  Prev: Auto Fill,  Up: Filling

29.5.2 Explicit Fill Commands
-----------------------------

`M-q'
     Fill current paragraph (`fill-paragraph').

`C-x f'
     Set the fill column (`set-fill-column').

`M-x fill-region'
     Fill each paragraph in the region (`fill-region').

`M-x fill-region-as-paragraph'
     Fill the region, considering it as one paragraph.

`M-o M-s'
     Center a line.

   To refill a paragraph, use the command `M-q' (`fill-paragraph').
This operates on the paragraph that point is inside, or the one after
point if point is between paragraphs.  Refilling works by removing all
the line-breaks, then inserting new ones where necessary.  When there
is an active region, this command operates on the text within the
region like `fill-region'.

   To refill many paragraphs, use `M-x fill-region', which finds the
paragraphs in the region and fills each of them.

   `M-q' and `fill-region' use the same criteria as `M-h' for finding
paragraph boundaries (*note Paragraphs::).  For more control, you can
use `M-x fill-region-as-paragraph', which refills everything between
point and mark as a single paragraph.  This command deletes any blank
lines within the region, so separate blocks of text end up combined
into one block.

   A numeric argument to `M-q' tells it to "justify" the text as well
as filling it.  This means that extra spaces are inserted to make the
right margin line up exactly at the fill column.  To remove the extra
spaces, use `M-q' with no argument.  (Likewise for `fill-region'.)
Another way to control justification, and choose other styles of
filling, is with the `justification' text property; see *note Format
Justification::.

   The command `M-o M-s' (`center-line') centers the current line
within the current fill column.  With an argument N, it centers N lines
individually and moves past them.  This binding is made by Text mode
and is available only in that and related modes (*note Text Mode::).

   The maximum line width for filling is in the variable `fill-column'.
Altering the value of `fill-column' makes it local to the current
buffer; until that time, the default value is in effect.  The default
is initially 70.  *Note Locals::.  The easiest way to set `fill-column'
is to use the command `C-x f' (`set-fill-column').  With a numeric
argument, it uses that as the new fill column.  With just `C-u' as
argument, it sets `fill-column' to the current horizontal position of
point.

   Emacs commands normally consider a period followed by two spaces or
by a newline as the end of a sentence; a period followed by just one
space indicates an abbreviation and not the end of a sentence.  To
preserve the distinction between these two ways of using a period, the
fill commands do not break a line after a period followed by just one
space.

   If the variable `sentence-end-double-space' is `nil', the fill
commands expect and leave just one space at the end of a sentence.
Ordinarily this variable is `t', so the fill commands insist on two
spaces for the end of a sentence, as explained above.  *Note
Sentences::.

   If the variable `colon-double-space' is non-`nil', the fill commands
put two spaces after a colon.

   The variable `fill-nobreak-predicate' is a hook (an abnormal hook,
*note Hooks::) specifying additional conditions where line-breaking is
not allowed.  Each function is called with no arguments, with point at
a place where Emacs is considering breaking the line.  If a function
returns a non-`nil' value, then that's a bad place to break the line.
Two standard functions you can use are `fill-single-word-nobreak-p'
(don't break after the first word of a sentence or before the last) and
`fill-french-nobreak-p' (don't break after `(' or before `)', `:' or
`?').


File: emacs,  Node: Fill Prefix,  Next: Adaptive Fill,  Prev: Fill Commands,  Up: Filling

29.5.3 The Fill Prefix
----------------------

To fill a paragraph in which each line starts with a special marker
(which might be a few spaces, giving an indented paragraph), you can use
the "fill prefix" feature.  The fill prefix is a string that Emacs
expects every line to start with, and which is not included in filling.
You can specify a fill prefix explicitly; Emacs can also deduce the
fill prefix automatically (*note Adaptive Fill::).

`C-x .'
     Set the fill prefix (`set-fill-prefix').

`M-q'
     Fill a paragraph using current fill prefix (`fill-paragraph').

`M-x fill-individual-paragraphs'
     Fill the region, considering each change of indentation as
     starting a new paragraph.

`M-x fill-nonuniform-paragraphs'
     Fill the region, considering only paragraph-separator lines as
     starting a new paragraph.

   To specify a fill prefix for the current buffer, move to a line that
starts with the desired prefix, put point at the end of the prefix, and
type `C-x .' (`set-fill-prefix').  (That's a period after the `C-x'.)
To turn off the fill prefix, specify an empty prefix: type `C-x .' with
point at the beginning of a line.

   When a fill prefix is in effect, the fill commands remove the fill
prefix from each line of the paragraph before filling and insert it on
each line after filling.  (The beginning of the first line of the
paragraph is left unchanged, since often that is intentionally
different.)  Auto Fill mode also inserts the fill prefix automatically
when it makes a new line.  The `C-o' command inserts the fill prefix on
new lines it creates, when you use it at the beginning of a line (*note
Blank Lines::).  Conversely, the command `M-^' deletes the prefix (if
it occurs) after the newline that it deletes (*note Indentation::).

   For example, if `fill-column' is 40 and you set the fill prefix to
`;; ', then `M-q' in the following text

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

produces this:

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

   Lines that do not start with the fill prefix are considered to start
paragraphs, both in `M-q' and the paragraph commands; this gives good
results for paragraphs with hanging indentation (every line indented
except the first one).  Lines which are blank or indented once the
prefix is removed also separate or start paragraphs; this is what you
want if you are writing multi-paragraph comments with a comment
delimiter on each line.

   You can use `M-x fill-individual-paragraphs' to set the fill prefix
for each paragraph automatically.  This command divides the region into
paragraphs, treating every change in the amount of indentation as the
start of a new paragraph, and fills each of these paragraphs.  Thus,
all the lines in one "paragraph" have the same amount of indentation.
That indentation serves as the fill prefix for that paragraph.

   `M-x fill-nonuniform-paragraphs' is a similar command that divides
the region into paragraphs in a different way.  It considers only
paragraph-separating lines (as defined by `paragraph-separate') as
starting a new paragraph.  Since this means that the lines of one
paragraph may have different amounts of indentation, the fill prefix
used is the smallest amount of indentation of any of the lines of the
paragraph.  This gives good results with styles that indent a
paragraph's first line more or less that the rest of the paragraph.

   The fill prefix is stored in the variable `fill-prefix'.  Its value
is a string, or `nil' when there is no fill prefix.  This is a
per-buffer variable; altering the variable affects only the current
buffer, but there is a default value which you can change as well.
*Note Locals::.

   The `indentation' text property provides another way to control the
amount of indentation paragraphs receive.  *Note Format Indentation::.


File: emacs,  Node: Adaptive Fill,  Next: Refill,  Prev: Fill Prefix,  Up: Filling

29.5.4 Adaptive Filling
-----------------------

The fill commands can deduce the proper fill prefix for a paragraph
automatically in certain cases: either whitespace or certain punctuation
characters at the beginning of a line are propagated to all lines of the
paragraph.

   If the paragraph has two or more lines, the fill prefix is taken from
the paragraph's second line, but only if it appears on the first line as
well.

   If a paragraph has just one line, fill commands _may_ take a prefix
from that line.  The decision is complicated because there are three
reasonable things to do in such a case:

   * Use the first line's prefix on all the lines of the paragraph.

   * Indent subsequent lines with whitespace, so that they line up
     under the text that follows the prefix on the first line, but
     don't actually copy the prefix from the first line.

   * Don't do anything special with the second and following lines.

   All three of these styles of formatting are commonly used.  So the
fill commands try to determine what you would like, based on the prefix
that appears and on the major mode.  Here is how.

   If the prefix found on the first line matches
`adaptive-fill-first-line-regexp', or if it appears to be a
comment-starting sequence (this depends on the major mode), then the
prefix found is used for filling the paragraph, provided it would not
act as a paragraph starter on subsequent lines.

   Otherwise, the prefix found is converted to an equivalent number of
spaces, and those spaces are used as the fill prefix for the rest of the
lines, provided they would not act as a paragraph starter on subsequent
lines.

   In Text mode, and other modes where only blank lines and page
delimiters separate paragraphs, the prefix chosen by adaptive filling
never acts as a paragraph starter, so it can always be used for filling.

   The variable `adaptive-fill-regexp' determines what kinds of line
beginnings can serve as a fill prefix: any characters at the start of
the line that match this regular expression are used.  If you set the
variable `adaptive-fill-mode' to `nil', the fill prefix is never chosen
automatically.

   You can specify more complex ways of choosing a fill prefix
automatically by setting the variable `adaptive-fill-function' to a
function.  This function is called with point after the left margin of a
line, and it should return the appropriate fill prefix based on that
line.  If it returns `nil', `adaptive-fill-regexp' gets a chance to
find a prefix.


File: emacs,  Node: Refill,  Next: Longlines,  Prev: Adaptive Fill,  Up: Filling

29.5.5 Refill Mode
------------------

Refill minor mode provides support for keeping paragraphs filled as you
type or modify them in other ways.  It provides an effect similar to
typical word processor behavior.  This works by running a
paragraph-filling command at suitable times.

   To toggle the use of Refill mode in the current buffer, type `M-x
refill-mode'.  When you are typing text, only characters which normally
trigger auto filling, like the space character, will trigger refilling.
This is to avoid making it too slow.  Apart from self-inserting
characters, other commands which modify the text cause refilling.

   The current implementation is preliminary and not robust.  You can
get better "line wrapping" behavior using Longlines mode.  *Note
Longlines::.  However, Longlines mode has an important side-effect: the
newlines that it inserts for you are not saved to disk, so the files
that you make with Longlines mode will appear to be completely unfilled
if you edit them without Longlines mode.


File: emacs,  Node: Longlines,  Prev: Refill,  Up: Filling

29.5.6 Long Lines Mode
----------------------

Sometimes, you may come across "unfilled" text files, which Emacs
normally displays as a bunch of extremely long lines.  Comfortably
reading and editing such files normally requires "word wrap", a feature
that breaks up each long text line into multiple screen lines in a
readable manner--by putting the breaks at word boundaries.  Many text
editors, such as those built into many web browsers, perform word
wrapping by default.

   There are two different minor modes in Emacs that perform word
wrapping.  The first is Visual Line mode, which does it by altering the
behavior of screen line continuation.  *Note Visual Line Mode::, for
information about Visual Line mode.

   Instead of using Visual Line mode, you can use a minor mode called
Long Lines mode.  Long Lines mode wraps lines by inserting or deleting
"soft newlines" as you type (*note Hard and Soft Newlines::).  These
soft newlines won't show up when you save the buffer into a file, or
when you copy the text into the kill ring, clipboard, or a register.
Unlike Visual Line mode, Lone Lines mode breaks long lines at the fill
column (*note Fill Commands::), rather than the right window edge.  To
enable Long Lines mode, type `M-x longlines-mode'.  If the text is full
of long lines, this also immediately "wraps" them all.

   The word wrap performed by Long Lines mode is _not_ the same as
ordinary filling (*note Fill Commands::).  It does not contract
multiple spaces into a single space, recognize fill prefixes (*note
Fill Prefix::), or perform adaptive filling (*note Adaptive Fill::).
The reason for this is that a wrapped line is still, conceptually, a
single line.  Each soft newline is equivalent to exactly one space in
that long line, and vice versa.  However, you can still call filling
functions such as `M-q', and these will work as expected, inserting
soft newlines that won't show up on disk or when the text is copied.
You can even rely entirely on the normal fill commands by turning off
automatic line wrapping, with `C-u M-x longlines-auto-wrap'.  To turn
automatic line wrapping back on, type `M-x longlines-auto-wrap'.

   Type `RET' to insert a hard newline, one which automatic refilling
will not remove.  If you want to see where all the hard newlines are,
type `M-x longlines-show-hard-newlines'.  This will mark each hard
newline with a special symbol.  The same command with a prefix argument
turns this display off.

   Long Lines mode does not change normal text files that are already
filled, since the existing newlines are considered hard newlines.
Before Long Lines can do anything, you need to transform each paragraph
into a long line.  One way is to set `fill-column' to a large number
(e.g., `C-u 9999 C-x f'), re-fill all the paragraphs, and then set
`fill-column' back to its original value.


File: emacs,  Node: Case,  Next: Text Mode,  Prev: Filling,  Up: Text

29.6 Case Conversion Commands
=============================

Emacs has commands for converting either a single word or any arbitrary
range of text to upper case or to lower case.

`M-l'
     Convert following word to lower case (`downcase-word').

`M-u'
     Convert following word to upper case (`upcase-word').

`M-c'
     Capitalize the following word (`capitalize-word').

`C-x C-l'
     Convert region to lower case (`downcase-region').

`C-x C-u'
     Convert region to upper case (`upcase-region').

   The word conversion commands are the most useful.  `M-l'
(`downcase-word') converts the word after point to lower case, moving
past it.  Thus, repeating `M-l' converts successive words.  `M-u'
(`upcase-word') converts to all capitals instead, while `M-c'
(`capitalize-word') puts the first letter of the word into upper case
and the rest into lower case.  All these commands convert several words
at once if given an argument.  They are especially convenient for
converting a large amount of text from all upper case to mixed case,
because you can move through the text using `M-l', `M-u' or `M-c' on
each word as appropriate, occasionally using `M-f' instead to skip a
word.

   When given a negative argument, the word case conversion commands
apply to the appropriate number of words before point, but do not move
point.  This is convenient when you have just typed a word in the wrong
case: you can give the case conversion command and continue typing.

   If a word case conversion command is given in the middle of a word,
it applies only to the part of the word which follows point.  (This is
comparable to what `M-d' (`kill-word') does.)  With a negative
argument, case conversion applies only to the part of the word before
point.

   The other case conversion commands are `C-x C-u' (`upcase-region')
and `C-x C-l' (`downcase-region'), which convert everything between
point and mark to the specified case.  Point and mark do not move.

   The region case conversion commands `upcase-region' and
`downcase-region' are normally disabled.  This means that they ask for
confirmation if you try to use them.  When you confirm, you may enable
the command, which means it will not ask for confirmation again.  *Note
Disabling::.


File: emacs,  Node: Text Mode,  Next: Outline Mode,  Prev: Case,  Up: Text

29.7 Text Mode
==============

When you edit files of text in a human language, it's more convenient
to use Text mode rather than Fundamental mode.  To enter Text mode, type
`M-x text-mode'.

   In Text mode, only blank lines and page delimiters separate
paragraphs.  As a result, paragraphs can be indented, and adaptive
filling determines what indentation to use when filling a paragraph.
*Note Adaptive Fill::.

   Text mode defines <TAB> to run `indent-relative' (*note
Indentation::), so that you can conveniently indent a line like the
previous line.

   Text mode turns off the features concerned with comments except when
you explicitly invoke them.  It changes the syntax table so that
single-quotes are considered part of words.  However, if a word starts
with single-quotes, these are treated as a prefix for purposes such as
capitalization.  That is, `M-c' will convert `'hello'' into `'Hello'',
as expected.

   If you indent the first lines of paragraphs, then you should use
Paragraph-Indent Text mode rather than Text mode.  In this mode, you do
not need to have blank lines between paragraphs, because the first-line
indentation is sufficient to start a paragraph; however paragraphs in
which every line is indented are not supported.  Use `M-x
paragraph-indent-text-mode' to enter this mode.  Use `M-x
paragraph-indent-minor-mode' to enable an equivalent minor mode in
situations where you can't change the major mode--in mail composition,
for instance.

   Text mode, and all the modes based on it, define `M-<TAB>' as the
command `ispell-complete-word', which performs completion of the
partial word in the buffer before point, using the spelling dictionary
as the space of possible words.  *Note Spelling::.  If your window
manager defines `M-<TAB>' to switch windows, you can type `<ESC> <TAB>'
or `C-M-i'.

   Entering Text mode runs the hook `text-mode-hook'.  Other major
modes related to Text mode also run this hook, followed by hooks of
their own; this includes Paragraph-Indent Text mode, Nroff mode, TeX
mode, Outline mode, and Message mode.  Hook functions on
`text-mode-hook' can look at the value of `major-mode' to see which of
these modes is actually being entered.  *Note Hooks::.


File: emacs,  Node: Outline Mode,  Next: TeX Mode,  Prev: Text Mode,  Up: Text

29.8 Outline Mode
=================

Outline mode is a major mode much like Text mode but intended for
editing outlines.  It allows you to make parts of the text temporarily
invisible so that you can see the outline structure.  Type `M-x
outline-mode' to switch to Outline mode as the major mode of the current
buffer.

   When Outline mode makes a line invisible, the line does not appear
on the screen.  The screen appears exactly as if the invisible line
were deleted, except that an ellipsis (three periods in a row) appears
at the end of the previous visible line.  (Multiple consecutive
invisible lines produce just one ellipsis.)

   Editing commands that operate on lines, such as `C-n' and `C-p',
treat the text of the invisible line as part of the previous visible
line.  Killing the ellipsis at the end of a visible line really kills
all the following invisible lines.

   Outline minor mode provides the same commands as the major mode,
Outline mode, but you can use it in conjunction with other major modes.
Type `M-x outline-minor-mode' to enable the Outline minor mode in the
current buffer.  You can also specify this in the text of a file, with
a file local variable of the form `mode: outline-minor' (*note File
Variables::).

   The major mode, Outline mode, provides special key bindings on the
`C-c' prefix.  Outline minor mode provides similar bindings with `C-c
@' as the prefix; this is to reduce the conflicts with the major mode's
special commands.  (The variable `outline-minor-mode-prefix' controls
the prefix used.)

   Entering Outline mode runs the hook `text-mode-hook' followed by the
hook `outline-mode-hook' (*note Hooks::).

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines.
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.
* Foldout::                        Folding means zooming in on outlines.


File: emacs,  Node: Outline Format,  Next: Outline Motion,  Up: Outline Mode

29.8.1 Format of Outlines
-------------------------

Outline mode assumes that the lines in the buffer are of two types:
"heading lines" and "body lines".  A heading line represents a topic in
the outline.  Heading lines start with one or more stars; the number of
stars determines the depth of the heading in the outline structure.
Thus, a heading line with one star is a major topic; all the heading
lines with two stars between it and the next one-star heading are its
subtopics; and so on.  Any line that is not a heading line is a body
line.  Body lines belong with the preceding heading line.  Here is an
example:

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

   A heading line together with all following body lines is called
collectively an "entry".  A heading line together with all following
deeper heading lines and their body lines is called a "subtree".

   You can customize the criterion for distinguishing heading lines by
setting the variable `outline-regexp'.  (The recommended ways to do
this are in a major mode function or with a file local variable.)  Any
line whose beginning has a match for this regexp is considered a
heading line.  Matches that start within a line (not at the left
margin) do not count.

   The length of the matching text determines the level of the heading;
longer matches make a more deeply nested level.  Thus, for example, if
a text formatter has commands `@chapter', `@section' and `@subsection'
to divide the document into chapters and sections, you could make those
lines count as heading lines by setting `outline-regexp' to
`"@chap\\|@\\(sub\\)*section"'.  Note the trick: the two words
`chapter' and `section' are equally long, but by defining the regexp to
match only `chap' we ensure that the length of the text matched on a
chapter heading is shorter, so that Outline mode will know that
sections are contained in chapters.  This works as long as no other
command starts with `@chap'.

   You can explicitly specify a rule for calculating the level of a
heading line by setting the variable `outline-level'.  The value of
`outline-level' should be a function that takes no arguments and
returns the level of the current heading.  The recommended ways to set
this variable are in a major mode command or with a file local variable.


File: emacs,  Node: Outline Motion,  Next: Outline Visibility,  Prev: Outline Format,  Up: Outline Mode

29.8.2 Outline Motion Commands
------------------------------

Outline mode provides special motion commands that move backward and
forward to heading lines.

`C-c C-n'
     Move point to the next visible heading line
     (`outline-next-visible-heading').

`C-c C-p'
     Move point to the previous visible heading line
     (`outline-previous-visible-heading').

`C-c C-f'
     Move point to the next visible heading line at the same level as
     the one point is on (`outline-forward-same-level').

`C-c C-b'
     Move point to the previous visible heading line at the same level
     (`outline-backward-same-level').

`C-c C-u'
     Move point up to a lower-level (more inclusive) visible heading
     line (`outline-up-heading').

   `C-c C-n' (`outline-next-visible-heading') moves down to the next
heading line.  `C-c C-p' (`outline-previous-visible-heading') moves
similarly backward.  Both accept numeric arguments as repeat counts.
The names emphasize that invisible headings are skipped, but this is
not really a special feature.  All editing commands that look for lines
ignore the invisible lines automatically.

   More powerful motion commands understand the level structure of
headings.  `C-c C-f' (`outline-forward-same-level') and `C-c C-b'
(`outline-backward-same-level') move from one heading line to another
visible heading at the same depth in the outline.  `C-c C-u'
(`outline-up-heading') moves backward to another heading that is less
deeply nested.


File: emacs,  Node: Outline Visibility,  Next: Outline Views,  Prev: Outline Motion,  Up: Outline Mode

29.8.3 Outline Visibility Commands
----------------------------------

The other special commands of outline mode are used to make lines
visible or invisible.  Their names all start with `hide' or `show'.
Most of them fall into pairs of opposites.  They are not undoable;
instead, you can undo right past them.  Making lines visible or
invisible is simply not recorded by the undo mechanism.

   Many of these commands act on the "current" heading line.  If point
is on a heading line, that is the current heading line; if point is on
a body line, the current heading line is the nearest preceding header
line.

`C-c C-c'
     Make the current heading line's body invisible (`hide-entry').

`C-c C-e'
     Make the current heading line's body visible (`show-entry').

`C-c C-d'
     Make everything under the current heading invisible, not including
     the heading itself (`hide-subtree').

`C-c C-s'
     Make everything under the current heading visible, including body,
     subheadings, and their bodies (`show-subtree').

`C-c C-l'
     Make the body of the current heading line, and of all its
     subheadings, invisible (`hide-leaves').

`C-c C-k'
     Make all subheadings of the current heading line, at all levels,
     visible (`show-branches').

`C-c C-i'
     Make immediate subheadings (one level down) of the current heading
     line visible (`show-children').

`C-c C-t'
     Make all body lines in the buffer invisible (`hide-body').

`C-c C-a'
     Make all lines in the buffer visible (`show-all').

`C-c C-q'
     Hide everything except the top N levels of heading lines
     (`hide-sublevels').

`C-c C-o'
     Hide everything except for the heading or body that point is in,
     plus the headings leading up from there to the top level of the
     outline (`hide-other').

   Two commands that are exact opposites are `C-c C-c' (`hide-entry')
and `C-c C-e' (`show-entry').  They apply to the body lines directly
following the current heading line.  Subheadings and their bodies are
not affected.

   Two more powerful opposites are `C-c C-d' (`hide-subtree') and `C-c
C-s' (`show-subtree').  Both apply to the current heading line's
"subtree": its body, all its subheadings, both direct and indirect, and
all of their bodies.  In other words, the subtree contains everything
following the current heading line, up to and not including the next
heading of the same or higher rank.

   Intermediate between a visible subtree and an invisible one is having
all the subheadings visible but none of the body.  There are two
commands for doing this, depending on whether you want to hide the
bodies or make the subheadings visible.  They are `C-c C-l'
(`hide-leaves') and `C-c C-k' (`show-branches').

   A little weaker than `show-branches' is `C-c C-i' (`show-children').
It makes just the direct subheadings visible--those one level down.
Deeper subheadings remain invisible, if they were invisible.

   Two commands have a blanket effect on the whole file.  `C-c C-t'
(`hide-body') makes all body lines invisible, so that you see just the
outline structure (as a special exception, it will not hide lines at
the top of the file, preceding the first header line, even though these
are technically body lines).  `C-c C-a' (`show-all') makes all lines
visible.  These commands can be thought of as a pair of opposites even
though `C-c C-a' applies to more than just body lines.

   The command `C-c C-q' (`hide-sublevels') hides all but the top level
headings.  With a numeric argument N, it hides everything except the
top N levels of heading lines.

   The command `C-c C-o' (`hide-other') hides everything except the
heading and body text that point is in, plus its parents (the headers
leading up from there to top level in the outline) and the top level
headings.

   When incremental search finds text that is hidden by Outline mode,
it makes that part of the buffer visible.  If you exit the search at
that position, the text remains visible.  You can also automatically
make text visible as you navigate in it by using `M-x reveal-mode'.


File: emacs,  Node: Outline Views,  Next: Foldout,  Prev: Outline Visibility,  Up: Outline Mode

29.8.4 Viewing One Outline in Multiple Views
--------------------------------------------

You can display two views of a single outline at the same time, in
different windows.  To do this, you must create an indirect buffer using
`M-x make-indirect-buffer'.  The first argument of this command is the
existing outline buffer name, and its second argument is the name to
use for the new indirect buffer.  *Note Indirect Buffers::.

   Once the indirect buffer exists, you can display it in a window in
the normal fashion, with `C-x 4 b' or other Emacs commands.  The Outline
mode commands to show and hide parts of the text operate on each buffer
independently; as a result, each buffer can have its own view.  If you
want more than two views on the same outline, create additional indirect
buffers.


File: emacs,  Node: Foldout,  Prev: Outline Views,  Up: Outline Mode

29.8.5 Folding Editing
----------------------

The Foldout package extends Outline mode and Outline minor mode with
"folding" commands.  The idea of folding is that you zoom in on a
nested portion of the outline, while hiding its relatives at higher
levels.

   Consider an Outline mode buffer with all the text and subheadings
under level-1 headings hidden.  To look at what is hidden under one of
these headings, you could use `C-c C-e' (`M-x show-entry') to expose
the body, or `C-c C-i' to expose the child (level-2) headings.

   With Foldout, you use `C-c C-z' (`M-x foldout-zoom-subtree').  This
exposes the body and child subheadings, and narrows the buffer so that
only the level-1 heading, the body and the level-2 headings are
visible.  Now to look under one of the level-2 headings, position the
cursor on it and use `C-c C-z' again.  This exposes the level-2 body
and its level-3 child subheadings and narrows the buffer again.  Zooming
in on successive subheadings can be done as much as you like.  A string
in the mode line shows how deep you've gone.

   When zooming in on a heading, to see only the child subheadings
specify a numeric argument: `C-u C-c C-z'.  The number of levels of
children can be specified too (compare `M-x show-children'), e.g. `M-2
C-c C-z' exposes two levels of child subheadings.  Alternatively, the
body can be specified with a negative argument: `M-- C-c C-z'.  The
whole subtree can be expanded, similarly to `C-c C-s' (`M-x
show-subtree'), by specifying a zero argument: `M-0 C-c C-z'.

   While you're zoomed in, you can still use Outline mode's exposure and
hiding functions without disturbing Foldout.  Also, since the buffer is
narrowed, "global" editing actions will only affect text under the
zoomed-in heading.  This is useful for restricting changes to a
particular chapter or section of your document.

   To unzoom (exit) a fold, use `C-c C-x' (`M-x foldout-exit-fold').
This hides all the text and subheadings under the top-level heading and
returns you to the previous view of the buffer.  Specifying a numeric
argument exits that many levels of folds.  Specifying a zero argument
exits all folds.

   To cancel the narrowing of a fold without hiding the text and
subheadings, specify a negative argument.  For example, `M--2 C-c C-x'
exits two folds and leaves the text and subheadings exposed.

   Foldout mode also provides mouse commands for entering and exiting
folds, and for showing and hiding text:

`C-M-Mouse-1' zooms in on the heading clicked on
          single click: expose body.

          double click: expose subheadings.

          triple click: expose body and subheadings.

          quad click: expose entire subtree.

`C-M-Mouse-2' exposes text under the heading clicked on
          single click: expose body.

          double click: expose subheadings.

          triple click: expose body and subheadings.

          quad click: expose entire subtree.

`C-M-Mouse-3' hides text under the heading clicked on or exits fold
          single click: hide subtree.

          double click: exit fold and hide text.

          triple click: exit fold without hiding text.

          quad click: exit all folds and hide text.

   You can specify different modifier keys (instead of `Control-Meta-')
by setting `foldout-mouse-modifiers'; but if you have already loaded
the `foldout.el' library, you must reload it in order for this to take
effect.

   To use the Foldout package, you can type `M-x load-library <RET>
foldout <RET>'; or you can arrange for to do that automatically by
putting this in your `.emacs' file:

     (eval-after-load "outline" '(require 'foldout))


File: emacs,  Node: TeX Mode,  Next: HTML Mode,  Prev: Outline Mode,  Up: Text

29.9 TeX Mode
=============

Emacs provides special major modes for editing files written in TeX and
its related formats.  TeX is a powerful text formatter written by
Donald Knuth; like GNU Emacs, it is free software.  LaTeX is a
simplified input format for TeX, implemented using TeX macros.  DocTeX
is a special file format in which the LaTeX sources are written,
combining sources with documentation.  SliTeX is an obsolete special
form of LaTeX.(1)

   TeX mode has four variants: Plain TeX mode, LaTeX mode, DocTeX mode,
and SliTeX mode.  These distinct major modes differ only slightly, and
are designed for editing the four different formats.  Emacs selects the
appropriate mode by looking at the contents of the buffer.  (This is
done by the `tex-mode' command, which is normally called automatically
when you visit a TeX-like file.  *Note Choosing Modes::.)  If the
contents are insufficient to determine this, Emacs chooses the mode
specified by the variable `tex-default-mode'; its default value is
`latex-mode'.  If Emacs does not guess right, you can select the
correct variant of TeX mode using the command `M-x plain-tex-mode', `M-x
latex-mode', `M-x slitex-mode', or `doctex-mode'.

   Emacs also provides BibTeX mode, a major mode for editing BibTeX
files.  BibTeX is a tool for storing and formatting bibliographic
references, which is commonly used together with LaTeX.  In addition,
the RefTeX package provides a minor mode which can be used in
conjunction with LaTeX mode to manage bibliographic references.  *note
(reftex)Top::.

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.
* Misc: TeX Misc.         Customization of TeX mode, and related features.

   ---------- Footnotes ----------

   (1) It has been replaced by the `slides' document class, which comes
with LaTeX.


File: emacs,  Node: TeX Editing,  Next: LaTeX Editing,  Up: TeX Mode

29.9.1 TeX Editing Commands
---------------------------

`"'
     Insert, according to context, either ```' or `"' or `'''
     (`tex-insert-quote').

`C-j'
     Insert a paragraph break (two newlines) and check the previous
     paragraph for unbalanced braces or dollar signs
     (`tex-terminate-paragraph').

`M-x tex-validate-region'
     Check each paragraph in the region for unbalanced braces or dollar
     signs.

`C-c {'
     Insert `{}' and position point between them (`tex-insert-braces').

`C-c }'
     Move forward past the next unmatched close brace (`up-list').

   In TeX, the character `"' is not normally used; instead, quotations
begin with ```' and end with `'''.  For convenience, TeX mode overrides
the normal meaning of the key `"' with a command that inserts a pair of
single-quotes or backquotes (`tex-insert-quote').  To be precise, it
inserts ```' after whitespace or an open brace, `"' after a backslash,
and `''' after any other character.

   As a special exception, if you type `"' when the text before point
is either ```' or `''', Emacs replaces that preceding text with a
single `"' character.  You can therefore type `""' to insert `"',
should you ever need to do so.  (You can also use `C-q "' to insert
this character.)

   To disable the `"' expansion feature, eliminate that binding in the
local map (*note Key Bindings::).

   In TeX mode, `$' has a special syntax code which attempts to
understand the way TeX math mode delimiters match.  When you insert a
`$' that is meant to exit math mode, the position of the matching `$'
that entered math mode is displayed for a second.  This is the same
feature that displays the open brace that matches a close brace that is
inserted.  However, there is no way to tell whether a `$' enters math
mode or leaves it; so when you insert a `$' that enters math mode, the
previous `$' position is shown as if it were a match, even though they
are actually unrelated.

   TeX uses braces as delimiters that must match.  Some users prefer to
keep braces balanced at all times, rather than inserting them singly.
Use `C-c {' (`tex-insert-braces') to insert a pair of braces.  It
leaves point between the two braces so you can insert the text that
belongs inside.  Afterward, use the command `C-c }' (`up-list') to move
forward past the close brace.

   There are two commands for checking the matching of braces.  `C-j'
(`tex-terminate-paragraph') checks the paragraph before point, and
inserts two newlines to start a new paragraph.  It outputs a message in
the echo area if any mismatch is found.  `M-x tex-validate-region'
checks a region, paragraph by paragraph.  The errors are listed in the
`*Occur*' buffer, and you can use `C-c C-c' or `Mouse-2' in that buffer
to go to a particular mismatch.

   Note that Emacs commands count square brackets and parentheses in
TeX mode, not just braces.  This is not strictly correct for the
purpose of checking TeX syntax.  However, parentheses and square
brackets are likely to be used in text as matching delimiters, and it
is useful for the various motion commands and automatic match display
to work with them.


File: emacs,  Node: LaTeX Editing,  Next: TeX Print,  Prev: TeX Editing,  Up: TeX Mode

29.9.2 LaTeX Editing Commands
-----------------------------

LaTeX mode (and its obsolete variant, SliTeX mode) provide a few extra
features not applicable to plain TeX:

`C-c C-o'
     Insert `\begin' and `\end' for LaTeX block and position point on a
     line between them (`tex-latex-block').

`C-c C-e'
     Close the innermost LaTeX block not yet closed
     (`tex-close-latex-block').

   In LaTeX input, `\begin' and `\end' commands are used to group
blocks of text.  To insert a `\begin' and a matching `\end' (on a new
line following the `\begin'), use `C-c C-o' (`tex-latex-block').  A
blank line is inserted between the two, and point is left there.  You
can use completion when you enter the block type; to specify additional
block type names beyond the standard list, set the variable
`latex-block-names'.  For example, here's how to add `theorem',
`corollary', and `proof':

     (setq latex-block-names '("theorem" "corollary" "proof"))

   In LaTeX input, `\begin' and `\end' commands must balance.  You can
use `C-c C-e' (`tex-close-latex-block') to insert automatically a
matching `\end' to match the last unmatched `\begin'.  It indents the
`\end' to match the corresponding `\begin'.  It inserts a newline after
`\end' if point is at the beginning of a line.


File: emacs,  Node: TeX Print,  Next: TeX Misc,  Prev: LaTeX Editing,  Up: TeX Mode

29.9.3 TeX Printing Commands
----------------------------

You can invoke TeX as an inferior of Emacs on either the entire
contents of the buffer or just a region at a time.  Running TeX in this
way on just one chapter is a good way to see what your changes look
like without taking the time to format the entire file.

`C-c C-r'
     Invoke TeX on the current region, together with the buffer's header
     (`tex-region').

`C-c C-b'
     Invoke TeX on the entire current buffer (`tex-buffer').

`C-c <TAB>'
     Invoke BibTeX on the current file (`tex-bibtex-file').

`C-c C-f'
     Invoke TeX on the current file (`tex-file').

`C-c C-l'
     Recenter the window showing output from the inferior TeX so that
     the last line can be seen (`tex-recenter-output-buffer').

`C-c C-k'
     Kill the TeX subprocess (`tex-kill-job').

`C-c C-p'
     Print the output from the last `C-c C-r', `C-c C-b', or `C-c C-f'
     command (`tex-print').

`C-c C-v'
     Preview the output from the last `C-c C-r', `C-c C-b', or `C-c
     C-f' command (`tex-view').

`C-c C-q'
     Show the printer queue (`tex-show-print-queue').

`C-c C-c'
     Invoke some other compilation command on the entire current buffer
     (`tex-compile').

   You can pass the current buffer through an inferior TeX by means of
`C-c C-b' (`tex-buffer').  The formatted output appears in a temporary
file; to print it, type `C-c C-p' (`tex-print').  Afterward, you can
use `C-c C-q' (`tex-show-print-queue') to view the progress of your
output towards being printed.  If your terminal has the ability to
display TeX output files, you can preview the output on the terminal
with `C-c C-v' (`tex-view').

   You can specify the directory to use for running TeX by setting the
variable `tex-directory'.  `"."' is the default value.  If your
environment variable `TEXINPUTS' contains relative directory names, or
if your files contains `\input' commands with relative file names, then
`tex-directory' _must_ be `"."' or you will get the wrong results.
Otherwise, it is safe to specify some other directory, such as `"/tmp"'.

   If you want to specify which shell commands are used in the inferior
TeX, you can do so by setting the values of the variables
`tex-run-command', `latex-run-command', `slitex-run-command',
`tex-dvi-print-command', `tex-dvi-view-command', and
`tex-show-queue-command'.  The default values may (or may not) be
appropriate for your system.

   Normally, the file name given to these commands comes at the end of
the command string; for example, `latex FILENAME'.  In some cases,
however, the file name needs to be embedded in the command; an example
is when you need to provide the file name as an argument to one command
whose output is piped to another.  You can specify where to put the
file name with `*' in the command string.  For example,

     (setq tex-dvi-print-command "dvips -f * | lpr")

   The terminal output from TeX, including any error messages, appears
in a buffer called `*tex-shell*'.  If TeX gets an error, you can switch
to this buffer and feed it input (this works as in Shell mode; *note
Interactive Shell::).  Without switching to this buffer you can scroll
it so that its last line is visible by typing `C-c C-l'.

   Type `C-c C-k' (`tex-kill-job') to kill the TeX process if you see
that its output is no longer useful.  Using `C-c C-b' or `C-c C-r' also
kills any TeX process still running.

   You can also pass an arbitrary region through an inferior TeX by
typing `C-c C-r' (`tex-region').  This is tricky, however, because most
files of TeX input contain commands at the beginning to set parameters
and define macros, without which no later part of the file will format
correctly.  To solve this problem, `C-c C-r' allows you to designate a
part of the file as containing essential commands; it is included before
the specified region as part of the input to TeX.  The designated part
of the file is called the "header".

   To indicate the bounds of the header in Plain TeX mode, you insert
two special strings in the file.  Insert `%**start of header' before the
header, and `%**end of header' after it.  Each string must appear
entirely on one line, but there may be other text on the line before or
after.  The lines containing the two strings are included in the header.
If `%**start of header' does not appear within the first 100 lines of
the buffer, `C-c C-r' assumes that there is no header.

   In LaTeX mode, the header begins with `\documentclass' or
`\documentstyle' and ends with `\begin{document}'.  These are commands
that LaTeX requires you to use in any case, so nothing special needs to
be done to identify the header.

   The commands (`tex-buffer') and (`tex-region') do all of their work
in a temporary directory, and do not have available any of the auxiliary
files needed by TeX for cross-references; these commands are generally
not suitable for running the final copy in which all of the
cross-references need to be correct.

   When you want the auxiliary files for cross references, use `C-c
C-f' (`tex-file') which runs TeX on the current buffer's file, in that
file's directory.  Before running TeX, it offers to save any modified
buffers.  Generally, you need to use (`tex-file') twice to get the
cross-references right.

   The value of the variable `tex-start-options' specifies options for
the TeX run.

   The value of the variable `tex-start-commands' specifies TeX
commands for starting TeX.  The default value causes TeX to run in
nonstop mode.  To run TeX interactively, set the variable to `""'.

   Large TeX documents are often split into several files--one main
file, plus subfiles.  Running TeX on a subfile typically does not work;
you have to run it on the main file.  In order to make `tex-file'
useful when you are editing a subfile, you can set the variable
`tex-main-file' to the name of the main file.  Then `tex-file' runs TeX
on that file.

   The most convenient way to use `tex-main-file' is to specify it in a
local variable list in each of the subfiles.  *Note File Variables::.

   For LaTeX files, you can use BibTeX to process the auxiliary file
for the current buffer's file.  BibTeX looks up bibliographic citations
in a data base and prepares the cited references for the bibliography
section.  The command `C-c <TAB>' (`tex-bibtex-file') runs the shell
command (`tex-bibtex-command') to produce a `.bbl' file for the current
buffer's file.  Generally, you need to do `C-c C-f' (`tex-file') once
to generate the `.aux' file, then do `C-c <TAB>' (`tex-bibtex-file'),
and then repeat `C-c C-f' (`tex-file') twice more to get the
cross-references correct.

   To invoke some other compilation program on the current TeX buffer,
type `C-c C-c' (`tex-compile').  This command knows how to pass
arguments to many common programs, including `pdflatex', `yap', `xdvi',
and `dvips'.  You can select your desired compilation program using the
standard completion keys (*note Completion::).


File: emacs,  Node: TeX Misc,  Prev: TeX Print,  Up: TeX Mode

29.9.4 TeX Mode Miscellany
--------------------------

Entering any variant of TeX mode runs the hooks `text-mode-hook' and
`tex-mode-hook'.  Then it runs either `plain-tex-mode-hook',
`latex-mode-hook', or `slitex-mode-hook', whichever is appropriate.
Starting the TeX shell runs the hook `tex-shell-hook'.  *Note Hooks::.

   The commands `M-x iso-iso2tex', `M-x iso-tex2iso', `M-x
iso-iso2gtex' and `M-x iso-gtex2iso' can be used to convert between
Latin-1 encoded files and TeX-encoded equivalents.

   For managing all kinds of references for LaTeX, you can use RefTeX.
*note (reftex)Top::.


File: emacs,  Node: HTML Mode,  Next: Nroff Mode,  Prev: TeX Mode,  Up: Text

29.10 SGML and HTML Modes
=========================

The major modes for SGML and HTML provide indentation support and
commands for operating on tags.  HTML mode is a slightly customized
variant of SGML mode.

`C-c C-n'
     Interactively specify a special character and insert the SGML
     `&'-command for that character.

`C-c C-t'
     Interactively specify a tag and its attributes (`sgml-tag').  This
     command asks you for a tag name and for the attribute values, then
     inserts both the opening tag and the closing tag, leaving point
     between them.

     With a prefix argument N, the command puts the tag around the N
     words already present in the buffer after point.  Whenever a
     region is active, it puts the tag around the region (when Transient
     Mark mode is off, it does this when a numeric argument of -1 is
     supplied.)

`C-c C-a'
     Interactively insert attribute values for the current tag
     (`sgml-attributes').

`C-c C-f'
     Skip across a balanced tag group (which extends from an opening tag
     through its corresponding closing tag) (`sgml-skip-tag-forward').
     A numeric argument acts as a repeat count.

`C-c C-b'
     Skip backward across a balanced tag group (which extends from an
     opening tag through its corresponding closing tag)
     (`sgml-skip-tag-forward').  A numeric argument acts as a repeat
     count.

`C-c C-d'
     Delete the tag at or after point, and delete the matching tag too
     (`sgml-delete-tag').  If the tag at or after point is an opening
     tag, delete the closing tag too; if it is a closing tag, delete the
     opening tag too.

`C-c ? TAG <RET>'
     Display a description of the meaning of tag TAG (`sgml-tag-help').
     If the argument TAG is empty, describe the tag at point.

`C-c /'
     Insert a close tag for the innermost unterminated tag
     (`sgml-close-tag').  If called from within a tag or a comment,
     close this element instead of inserting a close tag.

`C-c 8'
     Toggle a minor mode in which Latin-1 characters insert the
     corresponding SGML commands that stand for them, instead of the
     characters themselves (`sgml-name-8bit-mode').

`C-c C-v'
     Run a shell command (which you must specify) to validate the
     current buffer as SGML (`sgml-validate').

`C-c TAB'
     Toggle the visibility of existing tags in the buffer.  This can be
     used as a cheap preview.

   The default mode for editing XML documents is called nXML mode
(`xml-mode' or `nxml-mode').  This is a powerful major mode that can
recognize many existing XML schema and use them to provide completion
of XML elements via `C-<RET>' or `M-<TAB>', as well as "on-the-fly" XML
validation with error highlighting.  It is described in its own manual.
*Note nXML Mode: (nxml-mode)Top.

   However, you can also use SGML mode to edit XML, since XML is a
strict subset of SGML.  In XML, every opening tag must have an explicit
closing tag.  When the variable `sgml-xml-mode' is non-`nil', the tag
insertion commands described above always insert explicit closing tags
as well.  When you visit a file in SGML mode, Emacs determines whether
it is XML by examining the file contents, and sets `sgml-xml-mode'
accordingly.


File: emacs,  Node: Nroff Mode,  Next: Formatted Text,  Prev: HTML Mode,  Up: Text

29.11 Nroff Mode
================

Nroff mode is a mode like Text mode but modified to handle nroff
commands present in the text.  Invoke `M-x nroff-mode' to enter this
mode.  It differs from Text mode in only a few ways.  All nroff command
lines are considered paragraph separators, so that filling will never
garble the nroff commands.  Pages are separated by `.bp' commands.
Comments start with backslash-doublequote.  Also, three special
commands are provided that are not in Text mode:

`M-n'
     Move to the beginning of the next line that isn't an nroff command
     (`forward-text-line').  An argument is a repeat count.

`M-p'
     Like `M-n' but move up (`backward-text-line').

`M-?'
     Displays in the echo area the number of text lines (lines that are
     not nroff commands) in the region (`count-text-lines').

   The other feature of Nroff mode is that you can turn on Electric
Nroff mode.  This is a minor mode that you can turn on or off with `M-x
electric-nroff-mode' (*note Minor Modes::).  When the mode is on, each
time you use <RET> to end a line that contains an nroff command that
opens a kind of grouping, the matching nroff command to close that
grouping is automatically inserted on the following line.  For example,
if you are at the beginning of a line and type `. ( b <RET>', this
inserts the matching command `.)b' on a new line following point.

   If you use Outline minor mode with Nroff mode (*note Outline Mode::),
heading lines are lines of the form `.H' followed by a number (the
header level).

   Entering Nroff mode runs the hook `text-mode-hook', followed by the
hook `nroff-mode-hook' (*note Hooks::).


File: emacs,  Node: Formatted Text,  Next: Text Based Tables,  Prev: Nroff Mode,  Up: Text

29.12 Editing Formatted Text
============================

"Enriched mode" is a minor mode for editing files that contain
formatted text in WYSIWYG fashion, as in a word processor.  Currently,
formatted text in Enriched mode can specify fonts, colors, underlining,
margins, and types of filling and justification.  In the future, we plan
to implement other formatting features as well.

   Enriched mode is a minor mode (*note Minor Modes::).  It is
typically used in conjunction with Text mode (*note Text Mode::), but
you can also use it with other major modes such as Outline mode and
Paragraph-Indent Text mode.

   Potentially, Emacs can store formatted text files in various file
formats.  Currently, only one format is implemented: "text/enriched"
format, which is defined by the MIME protocol.  *Note Format
Conversion: (elisp)Format Conversion, for details of how Emacs
recognizes and converts file formats.

   The Emacs distribution contains a formatted text file that can serve
as an example.  Its name is `etc/enriched.doc'.  It contains samples
illustrating all the features described in this section.  It also
contains a list of ideas for future enhancements.

* Menu:

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the
                                  left or right margin, etc.
* Special: Format Properties.   The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.


File: emacs,  Node: Requesting Formatted Text,  Next: Hard and Soft Newlines,  Up: Formatted Text

29.12.1 Requesting to Edit Formatted Text
-----------------------------------------

Whenever you visit a file that Emacs saved in the text/enriched format,
Emacs automatically converts the formatting information in the file
into Emacs's own internal format (known as "text properties"), and
turns on Enriched mode.

   To create a new file of formatted text, first visit the nonexistent
file, then type `M-x enriched-mode' before you start inserting text.
This command turns on Enriched mode.  Do this before you begin inserting
text, to ensure that the text you insert is handled properly.

   More generally, the command `enriched-mode' turns Enriched mode on
if it was off, and off if it was on.  With a prefix argument, this
command turns Enriched mode on if the argument is positive, and turns
the mode off otherwise.

   When you save a buffer while Enriched mode is enabled in it, Emacs
automatically converts the text to text/enriched format while writing it
into the file.  When you visit the file again, Emacs will automatically
recognize the format, reconvert the text, and turn on Enriched mode
again.

   You can add annotations for saving additional text properties, which
Emacs normally does not save, by adding to `enriched-translations'.
Note that the text/enriched standard requires any non-standard
annotations to have names starting with `x-', as in `x-read-only'.
This ensures that they will not conflict with standard annotations that
may be added later.

   *Note Text Properties: (elisp)Text Properties, for more information
about text properties.


File: emacs,  Node: Hard and Soft Newlines,  Next: Editing Format Info,  Prev: Requesting Formatted Text,  Up: Formatted Text

29.12.2 Hard and Soft Newlines
------------------------------

In formatted text, Emacs distinguishes between two different kinds of
newlines, "hard" newlines and "soft" newlines.  (You can enable or
disable this feature separately in any  buffer with the command
`use-hard-newlines'.)

   Hard newlines are used to separate paragraphs, or items in a list, or
anywhere that there should always be a line break regardless of the
margins.  The <RET> command (`newline') and `C-o' (`open-line') insert
hard newlines.

   Soft newlines are used to make text fit between the margins.  All the
fill commands, including Auto Fill, insert soft newlines--and they
delete only soft newlines.

   Although hard and soft newlines look the same, it is important to
bear the difference in mind.  Do not use <RET> to break lines in the
middle of filled paragraphs, or else you will get hard newlines that are
barriers to further filling.  Instead, let Auto Fill mode break lines,
so that if the text or the margins change, Emacs can refill the lines
properly.  *Note Auto Fill::.

   On the other hand, in tables and lists, where the lines should always
remain as you type them, you can use <RET> to end lines.  For these
lines, you may also want to set the justification style to `unfilled'.
*Note Format Justification::.


File: emacs,  Node: Editing Format Info,  Next: Format Faces,  Prev: Hard and Soft Newlines,  Up: Formatted Text

29.12.3 Editing Format Information
----------------------------------

There are two ways to alter the formatting information for a formatted
text file: with keyboard commands, and with the mouse.

   The easiest way to add properties to your document is with the Text
Properties menu.  You can get to this menu in two ways: from the Edit
menu in the menu bar (use `<F10> e t' if you have no mouse), or with
`C-Mouse-2' (hold the <CTRL> key and press the middle mouse button).
There are also keyboard commands described in the following section.

   These items in the Text Properties menu run commands directly:

`Remove Face Properties'
     Delete from the region all face and color text properties
     (`facemenu-remove-face-props').

`Remove Text Properties'
     Delete _all_ text properties from the region
     (`facemenu-remove-all').

`Describe Properties'
     List all the text properties, widgets, buttons, and overlays of the
     character following point (`describe-text-properties').

`Display Faces'
     Display a list of all the defined faces (`list-faces-display').

`Display Colors'
     Display a list of all the defined colors (`list-colors-display').

   Other items in the Text Properties menu lead to submenus:

* Menu:

* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the
                                  left or right margin, etc.
* Special: Format Properties.   The "special" text properties submenu.


File: emacs,  Node: Format Faces,  Next: Format Colors,  Prev: Editing Format Info,  Up: Formatted Text

29.12.4 Faces in Formatted Text
-------------------------------

The Faces submenu under Text Properties lists various Emacs faces
including `bold', `italic', and `underline' (*note Faces::).  These
menu items operate on the region if it is active and nonempty.
Otherwise, they specify to use that face for an immediately following
self-inserting character.  There is also an item `Other' with which you
can enter a face name through the minibuffer (*note Standard Faces::).

   Instead of the Faces submenu, you can use these keyboard commands:

`M-o d'
     Remove all `face' properties from the region (which includes
     specified colors), or force the following inserted character to
     have no `face' property (`facemenu-set-default').  

`M-o b'
     Add the face `bold' to the region or to the following inserted
     character (`facemenu-set-bold').  

`M-o i'
     Add the face `italic' to the region or to the following inserted
     character (`facemenu-set-italic').  

`M-o l'
     Add the face `bold-italic' to the region or to the following
     inserted character (`facemenu-set-bold-italic').  

`M-o u'
     Add the face `underline' to the region or to the following inserted
     character (`facemenu-set-underline').  

`M-o o FACE <RET>'
     Add the face FACE to the region or to the following inserted
     character (`facemenu-set-face').

   With a prefix argument, all these commands apply to an immediately
following self-inserting character, disregarding the region.

   A self-inserting character normally inherits the `face' property
(and most other text properties) from the preceding character in the
buffer.  If you use the above commands to specify face for the next
self-inserting character, or the next section's commands to specify a
foreground or background color for it, then it does not inherit the
`face' property from the preceding character; instead it uses whatever
you specified.  It will still inherit other text properties, though.

   Strictly speaking, these commands apply only to the first following
self-inserting character that you type.  But if you insert additional
characters after it, they will inherit from the first one.  So it
appears that these commands apply to all of them.

   Enriched mode defines two additional faces: `excerpt' and `fixed'.
These correspond to codes used in the text/enriched file format.

   The `excerpt' face is intended for quotations.  This face is the
same as `italic' unless you customize it (*note Face Customization::).

   The `fixed' face means, "Use a fixed-width font for this part of the
text."  Applying the `fixed' face to a part of the text will cause that
part of the text to appear in a fixed-width font, even if the default
font is variable-width.  This applies to Emacs and to other systems
that display text/enriched format.  So if you specifically want a
certain part of the text to use a fixed-width font, you should specify
the `fixed' face for that part.

   By default, the `fixed' face looks the same as `bold'.  This is an
attempt to distinguish it from `default'.  You may wish to customize
`fixed' to some other fixed-width medium font.  *Note Face
Customization::.

   If your terminal cannot display different faces, you will not be
able to see them, but you can still edit documents containing faces,
and even add faces and colors to documents.  The faces you specify will
be visible when the file is viewed on a terminal that can display them.


File: emacs,  Node: Format Colors,  Next: Format Indentation,  Prev: Format Faces,  Up: Formatted Text

29.12.5 Colors in Formatted Text
--------------------------------

You can specify foreground and background colors for portions of the
text.  Under Text Properties, there is a submenu for specifying the
foreground color, and a submenu for specifying the background color.
Each one lists all the colors that you have used in Enriched mode in
the current Emacs session.

   If the region is active, the command applies to the text in the
region; otherwise, it applies to any immediately following
self-inserting input.  When Transient Mark mode is off (*note
Persistent Mark::), it always applies to the region unless a prefix
argument is given, in which case it applies to the following input.

   Each of the two color submenus contains one additional item:
`Other'.  You can use this item to specify a color that is not listed
in the menu; it reads the color name with the minibuffer.  To display a
list of available colors and their names, use the `Display Colors' menu
item in the Text Properties menu (*note Editing Format Info::).

   Any color that you specify in this way, or that is mentioned in a
formatted text file that you read in, is added to the corresponding
color menu for the duration of the Emacs session.

   There are no predefined key bindings for specifying colors, but you
can do so with the extended commands `M-x facemenu-set-foreground' and
`M-x facemenu-set-background'.  Both of these commands read the name of
the color with the minibuffer.


File: emacs,  Node: Format Indentation,  Next: Format Justification,  Prev: Format Colors,  Up: Formatted Text

29.12.6 Indentation in Formatted Text
-------------------------------------

When editing formatted text, you can specify different amounts of
indentation for the right or left margin of an entire paragraph or a
part of a paragraph.  The margins you specify automatically affect the
Emacs fill commands (*note Filling::) and line-breaking commands.

   The Indentation submenu of Text Properties provides a convenient
interface for specifying these properties.  The submenu contains four
items:

`Indent More'
     Indent the region by 4 columns (`increase-left-margin').  In
     Enriched mode, this command is also available on `C-x <TAB>'; if
     you supply a numeric argument, that says how many columns to add
     to the margin (a negative argument reduces the number of columns).

`Indent Less'
     Remove 4 columns of indentation from the region.

`Indent Right More'
     Make the text narrower by indenting 4 columns at the right margin.

`Indent Right Less'
     Remove 4 columns of indentation from the right margin.

   You can use these commands repeatedly to increase or decrease the
indentation.

   The most common way to use them is to change the indentation of an
entire paragraph.  For other uses, the effects of refilling can be hard
to predict, except in some special cases like the one described next.

   The most common other use is to format paragraphs with "hanging
indents", which means that the first line is indented less than
subsequent lines.  To set up a hanging indent, increase the indentation
of the region starting after the first word of the paragraph and
running until the end of the paragraph.

   Indenting the first line of a paragraph is easier.  Set the margin
for the whole paragraph where you want it to be for the body of the
paragraph, then indent the first line by inserting extra spaces or tabs.

   The variable `standard-indent' specifies how many columns these
commands should add to or subtract from the indentation.  The default
value is 4.  The overall default right margin for Enriched mode is
controlled by the variable `fill-column', as usual.

   There are also two commands for setting the left or right margin of
the region absolutely: `set-left-margin' and `set-right-margin'.
Enriched mode binds these commands to `C-c [' and `C-c ]',
respectively.  You can specify the margin width either with a numeric
argument or in the minibuffer.

   Sometimes, as a result of editing, the filling of a paragraph becomes
messed up--parts of the paragraph may extend past the left or right
margins.  When this happens, use `M-q' (`fill-paragraph') to refill the
paragraph.

   The fill prefix, if any, works in addition to the specified paragraph
indentation: `C-x .' does not include the specified indentation's
whitespace in the new value for the fill prefix, and the fill commands
look for the fill prefix after the indentation on each line.  *Note
Fill Prefix::.


File: emacs,  Node: Format Justification,  Next: Format Properties,  Prev: Format Indentation,  Up: Formatted Text

29.12.7 Justification in Formatted Text
---------------------------------------

When editing formatted text, you can specify various styles of
justification for a paragraph.  The style you specify automatically
affects the Emacs fill commands.

   The Justification submenu of Text Properties provides a convenient
interface for specifying the style.  The submenu contains five items:

`Left'
     This is the most common style of justification (at least for
     English).  Lines are aligned at the left margin but left uneven at
     the right.

`Right'
     This aligns each line with the right margin.  Spaces and tabs are
     added on the left, if necessary, to make lines line up on the
     right.

`Full'
     This justifies the text, aligning both edges of each line.
     Justified text looks very nice in a printed book, where the spaces
     can all be adjusted equally, but it does not look as nice with a
     fixed-width font on the screen.  Perhaps a future version of Emacs
     will be able to adjust the width of spaces in a line to achieve
     elegant justification.

`Center'
     This centers every line between the current margins.

`Unfilled'
     This turns off filling entirely.  Each line will remain as you
     wrote it; the fill and auto-fill functions will have no effect on
     text which has this setting.  You can, however, still indent the
     left margin.  In unfilled regions, all newlines are treated as
     hard newlines (*note Hard and Soft Newlines::) .

   In Enriched mode, you can also specify justification from the
keyboard using the `M-j' prefix character:

`M-j l'
     Make the region left-filled (`set-justification-left').  

`M-j r'
     Make the region right-filled (`set-justification-right').  

`M-j b'
     Make the region fully justified (`set-justification-full').  

`M-j c'
`M-S'
     Make the region centered (`set-justification-center').  

`M-j u'
     Make the region unfilled (`set-justification-none').

   Justification styles apply to entire paragraphs.  All the
justification-changing commands operate on the paragraph containing
point, or, if the region is active, on all paragraphs which overlap the
region.

   The default justification style is specified by the variable
`default-justification'.  Its value should be one of the symbols
`left', `right', `full', `center', or `none'.  This is a per-buffer
variable.  Setting the variable directly affects only the current
buffer.  However, customizing it in a Custom buffer sets (as always)
the default value for buffers that do not override it.  *Note Locals::,
and *note Easy Customization::.


File: emacs,  Node: Format Properties,  Next: Forcing Enriched Mode,  Prev: Format Justification,  Up: Formatted Text

29.12.8 Setting Other Text Properties
-------------------------------------

The Special Properties submenu of Text Properties can add or remove
three other useful text properties: `read-only', `invisible' and
`intangible'.  The `intangible' property disallows moving point within
the text, the `invisible' text property hides text from display, and
the `read-only' property disallows alteration of the text.

   Each of these special properties has a menu item to add it to the
region.  The last menu item, `Remove Special', removes all of these
special properties from the text in the region.

   Currently, the `invisible' and `intangible' properties are _not_
saved in the text/enriched format.  The `read-only' property is saved,
but it is not a standard part of the text/enriched format, so other
editors may not respect it.


File: emacs,  Node: Forcing Enriched Mode,  Prev: Format Properties,  Up: Formatted Text

29.12.9 Forcing Enriched Mode
-----------------------------

Normally, Emacs knows when you are editing formatted text because it
recognizes the special annotations used in the file that you visited.
However, sometimes you must take special actions to convert file
contents or turn on Enriched mode:

   * When you visit a file that was created with some other editor,
     Emacs may not recognize the file as being in the text/enriched
     format.  In this case, when you visit the file you will see the
     formatting commands rather than the formatted text.  Type `M-x
     format-decode-buffer' to translate it.  This also automatically
     turns on Enriched mode.

   * When you _insert_ a file into a buffer, rather than visiting it,
     Emacs does the necessary conversions on the text which you insert,
     but it does not enable Enriched mode.  If you wish to do that,
     type `M-x enriched-mode'.

   The command `format-decode-buffer' translates text in various
formats into Emacs's internal format.  It asks you to specify the format
to translate from; however, normally you can type just <RET>, which
tells Emacs to guess the format.

   If you wish to look at a text/enriched file in its raw form, as a
sequence of characters rather than as formatted text, use the `M-x
find-file-literally' command.  This visits a file, like `find-file',
but does not do format conversion.  It also inhibits character code
conversion (*note Coding Systems::) and automatic uncompression (*note
Compressed Files::).  To disable format conversion but allow character
code conversion and/or automatic uncompression if appropriate, use
`format-find-file' with suitable arguments.


File: emacs,  Node: Text Based Tables,  Prev: Formatted Text,  Up: Text

29.13 Editing Text-based Tables
===============================

Table mode provides an easy and intuitive way to create and edit WYSIWYG
text-based tables.  Here is an example of such a table:

     +-----------------+--------------------------------+-----------------+
     |     Command     |          Description           |   Key Binding   |
     +-----------------+--------------------------------+-----------------+
     |  forward-char   |Move point right N characters   |       C-f       |
     |                 |(left if N is negative).        |                 |
     |                 |                                |                 |
     |                 |On reaching end of buffer, stop |                 |
     |                 |and signal error.               |                 |
     +-----------------+--------------------------------+-----------------+
     |  backward-char  |Move point left N characters    |       C-b       |
     |                 |(right if N is negative).       |                 |
     |                 |                                |                 |
     |                 |On attempt to pass beginning or |                 |
     |                 |end of buffer, stop and signal  |                 |
     |                 |error.                          |                 |
     +-----------------+--------------------------------+-----------------+

   Table mode allows the contents of the table such as this one to be
easily manipulated by inserting or deleting characters inside a cell.
A cell is effectively a localized rectangular edit region and edits to
a cell do not affect the contents of the surrounding cells.  If the
contents do not fit into a cell, then the cell is automatically
expanded in the vertical and/or horizontal directions and the rest of
the table is restructured and reformatted in accordance with the growth
of the cell.

* Menu:

* Table Definition::          What is a text based table.
* Table Creation::            How to create a table.
* Table Recognition::         How to activate and deactivate tables.
* Cell Commands::             Cell-oriented commands in a table.
* Cell Justification::        Justifying cell contents.
* Row Commands::              Manipulating rows of table cell.
* Column Commands::           Manipulating columns of table cell.
* Fixed Width Mode::          Fixing cell width.
* Table Conversion::          Converting between plain text and tables.
* Measuring Tables::          Analyzing table dimension.
* Table Misc::                Table miscellany.


File: emacs,  Node: Table Definition,  Next: Table Creation,  Up: Text Based Tables

29.13.1 What is a Text-based Table?
-----------------------------------

Keep the following examples of valid tables in mind as a reference
while you read this section:

                   +--+----+---+     +-+     +--+-----+
                   |  |    |   |     | |     |  |     |
                   +--+----+---+     +-+     |  +--+--+
                   |  |    |   |             |  |  |  |
                   +--+----+---+             +--+--+  |
                                             |     |  |
                                             +-----+--+

   A table consists of a rectangular frame whose inside is divided into
cells.  Each cell must be at least one character wide and one character
high, not counting its border lines.  A cell can be subdivided into
multiple rectangular cells, but cells cannot overlap.

   The table frame and cell border lines are made of three special
characters.  These variables specify those characters:

`table-cell-vertical-char'
     Holds the character used for vertical lines.  The default value is
     `|'.

`table-cell-horizontal-chars'
     Holds the characters used for horizontal lines.  The default value
     is `"-="'.

`table-cell-intersection-char'
     Holds the character used at where horizontal line and vertical line
     meet.  The default value is `+'.

Based on this definition, the following five tables are examples of
invalid tables:

        +-----+    +-----+       +--+    +-++--+    ++
        |     |    |     |       |  |    | ||  |    ++
        | +-+ |    |     |       |  |    | ||  |
        | | | |    +--+  |    +--+--+    +-++--+
        | +-+ |    |  |  |    |  |  |    +-++--+
        |     |    |  |  |    |  |  |    | ||  |
        +-----+    +--+--+    +--+--+    +-++--+
          a           b          c          d        e

   From left to right:

  a. Overlapped cells or non-rectangular cells are not allowed.

  b. Same as a.

  c. The border must be rectangular.

  d. Cells must have a minimum width/height of one character.

  e. Same as d.


File: emacs,  Node: Table Creation,  Next: Table Recognition,  Prev: Table Definition,  Up: Text Based Tables

29.13.2 How to Create a Table?
------------------------------

The command to create a table is `table-insert'.  When called
interactively, it asks for the number of columns, number of rows, cell
width and cell height.  The number of columns is the number of cells
horizontally side by side.  The number of rows is the number of cells
vertically within the table's height.  The cell width is a number of
characters that each cell holds, left to right.  The cell height is a
number of lines each cell holds.  The cell width and the cell height
can be either an integer (when the value is constant across the table)
or a series of integer, separated by spaces or commas, where each
number corresponds to the next cell within a row from left to right, or
the next cell within a column from top to bottom.


File: emacs,  Node: Table Recognition,  Next: Cell Commands,  Prev: Table Creation,  Up: Text Based Tables

29.13.3 Table Recognition
-------------------------

Table mode maintains special text properties in the buffer to allow
editing in a convenient fashion.  When a buffer with tables is saved to
its file, these text properties are lost, so when you visit this file
again later, Emacs does not see a table, but just formatted text.  To
resurrect the table text properties, issue the `M-x table-recognize'
command.  It scans the current buffer, recognizes valid table cells,
and attaches appropriate text properties to allow for table editing.
The converse command, `table-unrecognize', is used to remove the
special text properties and convert the buffer back to plain text.

   Special commands exist to enable or disable tables within a region,
enable or disable individual tables, and enable/disable individual
cells.  These commands are:

`M-x table-recognize-region'
     Recognize tables within the current region and activate them.  

`M-x table-unrecognize-region'
     Deactivate tables within the current region.  

`M-x table-recognize-table'
     Recognize the table under point and activate it.  

`M-x table-unrecognize-table'
     Deactivate the table under point.  

`M-x table-recognize-cell'
     Recognize the cell under point and activate it.  

`M-x table-unrecognize-cell'
     Deactivate the cell under point.

   For another way of converting text into tables, see *note Table
Conversion::.


File: emacs,  Node: Cell Commands,  Next: Cell Justification,  Prev: Table Recognition,  Up: Text Based Tables

29.13.4 Commands for Table Cells
--------------------------------

The commands `table-forward-cell' and `table-backward-cell' move point
from the current cell to an adjacent cell forward and backward
respectively.  The order of the cells is cyclic: when point is in the
last cell of a table, typing `M-x table-forward-cell' moves to the
first cell in the table.  Likewise `M-x table-backward-cell' from the
first cell in a table moves to the last cell.

   The command `table-span-cell' merges the current cell with the
adjacent cell in a specified direction--right, left, above or below.
You specify the direction with the minibuffer.  It does not allow
merges which don't result in a legitimate cell layout.

   The command `table-split-cell' splits the current cell vertically or
horizontally.  This command is a wrapper to the direction specific
commands `table-split-cell-vertically' and
`table-split-cell-horizontally'.  You specify the direction with a
minibuffer argument.

   The command `table-split-cell-vertically' splits the current cell
vertically and creates a pair of cells above and below where point is
located.  The content in the original cell is split as well.

   The command `table-split-cell-horizontally' splits the current cell
horizontally and creates a pair of cells right and left of where point
is located.  If the cell being split is not empty, this asks you how to
handle the cell contents.  The three options are: `split', `left', or
`right'.  `split' splits the contents at point literally, while the
`left' and `right' options move the entire contents into the left or
right cell respectively.

   The next four commands enlarge or shrink a cell.  They use numeric
arguments (*note Arguments::) to specify how many columns or rows to
enlarge or shrink a particular table.

`M-x table-heighten-cell'
     Enlarge the current cell vertically.  

`M-x table-shorten-cell'
     Shrink the current cell vertically.  

`M-x table-widen-cell'
     Enlarge the current cell horizontally.  

`M-x table-narrow-cell'
     Shrink the current cell horizontally.


File: emacs,  Node: Cell Justification,  Next: Row Commands,  Prev: Cell Commands,  Up: Text Based Tables

29.13.5 Cell Justification
--------------------------

You can specify text justification for each cell.  The justification is
remembered independently for each cell and the subsequent editing of
cell contents is subject to the specified justification.

   The command `table-justify' ask you to specify what to justify: a
cell, a column, or a row.  If you select cell justification, this
command sets the justification only for the current cell.  Selecting
column or row justification sets the justification for all the cells
within a column or row respectively.  The command then ask you which
kind of justification to apply: `left', `center', `right', `top',
`middle', `bottom', or `none'.  Horizontal justification and vertical
justification are specified independently.  The options `left',
`center', and `right' specify horizontal justification while the options
`top', `middle', `bottom', and `none' specify vertical justification.
The vertical justification `none' effectively removes vertical
justification.  Horizontal justification must be one of `left',
`center', or `right'.

   Justification information is stored in the buffer as a part of text
property.  Therefore, this information is ephemeral and does not
survive through the loss of the buffer (closing the buffer and
revisiting the buffer erase any previous text properties).  To
countermand for this, the command `table-recognize' and other
recognition commands (*note Table Recognition::) are equipped with a
convenience feature (turned on by default).  During table recognition,
the contents of a cell are examined to determine which justification
was originally applied to the cell and then applies this justification
to the cell.  This is a speculative algorithm and is therefore not
perfect, however, the justification is deduced correctly most of the
time.  To disable this feature, customize the variable
`table-detect-cell-alignment' and set it to `nil'.


File: emacs,  Node: Row Commands,  Next: Column Commands,  Prev: Cell Justification,  Up: Text Based Tables

29.13.6 Commands for Table Rows
-------------------------------

The command `table-insert-row' inserts a row of cells before the
current row in a table.  The current row where point is located is
pushed down after the newly inserted row.  A numeric prefix argument
specifies the number of rows to insert.  Note that in order to insert
rows _after_ the last row at the bottom of a table, you must place
point below the table--that is, outside the table--prior to invoking
this command.

   The command `table-delete-row' deletes a row of cells at point.  A
numeric prefix argument specifies the number of rows to delete.


File: emacs,  Node: Column Commands,  Next: Fixed Width Mode,  Prev: Row Commands,  Up: Text Based Tables

29.13.7 Commands for Table Columns
----------------------------------

The command `table-insert-column' inserts a column of cells to the left
of the current row in a table.  This pushes the current column to the
right.  To insert a column to the right side of the rightmost column,
place point to the right of the rightmost column, which is outside of
the table, prior to invoking this command.  A numeric prefix argument
specifies the number of columns to insert.

   A command `table-delete-column' deletes a column of cells at point.
A numeric prefix argument specifies the number of columns to delete.


File: emacs,  Node: Fixed Width Mode,  Next: Table Conversion,  Prev: Column Commands,  Up: Text Based Tables

29.13.8 Fix Width of Cells
--------------------------

The command `table-fixed-width-mode' toggles fixed width mode on and
off.  When fixed width mode is turned on, editing inside a cell never
changes the cell width; when it is off, the cell width expands
automatically in order to prevent a word from being folded into
multiple lines.  By default, fixed width mode is disabled.


File: emacs,  Node: Table Conversion,  Next: Measuring Tables,  Prev: Fixed Width Mode,  Up: Text Based Tables

29.13.9 Conversion Between Plain Text and Tables
------------------------------------------------

The command `table-capture' captures plain text in a region and turns
it into a table.  Unlike `table-recognize' (*note Table Recognition::),
the original text does not have a table appearance but may hold a
logical table structure.  For example, some elements separated by known
patterns form a two dimensional structure which can be turned into a
table.

   Here's an example of data that `table-capture' can operate on.  The
numbers are horizontally separated by a comma and vertically separated
by a newline character.

     1, 2, 3, 4
     5, 6, 7, 8
     , 9, 10

Invoking `M-x table-capture' on that text produces this table:

     +-----+-----+-----+-----+
     |1    |2    |3    |4    |
     +-----+-----+-----+-----+
     |5    |6    |7    |8    |
     +-----+-----+-----+-----+
     |     |9    |10   |     |
     +-----+-----+-----+-----+

The conversion uses `,' for the column delimiter and newline for a row
delimiter, cells are left justified, and minimum cell width is 5.

   The command `table-release' does the opposite of `table-capture'.
It releases a table by removing the table frame and cell borders.  This
leaves the table contents as plain text.  One of the useful
applications of `table-capture' and `table-release' is to edit a text
in layout.  Look at the following three paragraphs (the latter two are
indented with header lines):

     `table-capture' is a powerful command, but mastering its
     power requires some practice.  Here are some things it can do:

     Parse Cell Items      By using column delimiter regular
                           expression and raw delimiter regular
                           expression, it parses the specified text
                           area and extracts cell items from
                           non-table text and then forms a table out
                           of them.

     Capture Text Area     When no delimiters are specified it
                           creates a single cell table.  The text in
                           the specified region is placed in that
                           cell.

Applying `table-capture' to a region containing the above three
paragraphs, with empty strings for column delimiter regexp and row
delimiter regexp, creates a table with a single cell like the following
one.

     +-----------------------------------------------------------------+
     |`table-capture' is a powerful command, but mastering its         |
     |power requires some practice.  Here are some things it can do:   |
     |                                                                 |
     |Parse Cell Items      By using column delimiter regular          |
     |                      expression and raw delimiter regular       |
     |                      expression, it parses the specified text   |
     |                      area and extracts cell items from          |
     |                      non-table text and then forms a table out  |
     |                      of them.                                   |
     |                                                                 |
     |Capture Text Area     When no delimiters are specified it        |
     |                      creates a single cell table.  The text in  |
     |                      the specified region is placed in that     |
     |                      cell.                                      |
     +-----------------------------------------------------------------+

By splitting the cell appropriately we now have a table consisting of
paragraphs occupying its own cell.  Each cell can now be edited
independently without affecting the layout of other cells.

     +-----------------------------------------------------------------+
     |`table-capture' is a powerful command, but mastering its         |
     |power requires some practice.  Here are some things it can do:   |
     +---------------------+-------------------------------------------+
     |Parse Cell Items     |By using column delimiter regular          |
     |                     |expression and raw delimiter regular       |
     |                     |expression, it parses the specified text   |
     |                     |area and extracts cell items from          |
     |                     |non-table text and then forms a table out  |
     |                     |of them.                                   |
     +---------------------+-------------------------------------------+
     |Capture Text Area    |When no delimiters are specified it        |
     |                     |creates a single cell table.  The text in  |
     |                     |the specified region is placed in that     |
     |                     |cell.                                      |
     +---------------------+-------------------------------------------+

By applying `table-release', which does the opposite process, the
contents become once again plain text.  `table-release' works as a
companion command to `table-capture'.


File: emacs,  Node: Measuring Tables,  Next: Table Misc,  Prev: Table Conversion,  Up: Text Based Tables

29.13.10 Analyzing Table Dimensions
-----------------------------------

The command `table-query-dimension' analyzes a table structure and
reports information regarding its dimensions.  In case of the above
example table, the `table-query-dimension' command displays in echo
area:

     Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5

This indicates that the current cell is 21 character wide and 6 lines
high, the entire table is 67 characters wide and 16 lines high.  The
table has 2 columns and 3 rows.  It has a total of 5 cells, since the
first row has a spanned cell.


File: emacs,  Node: Table Misc,  Prev: Measuring Tables,  Up: Text Based Tables

29.13.11 Table Miscellany
-------------------------

The command `table-insert-sequence' inserts a string into each cell.
Each string is a part of a sequence i.e. a series of increasing integer
numbers.

   The command `table-generate-source' generates a table formatted for
a specific markup language.  It asks for a language (which must be one
of `html', `latex', or `cals'), a destination buffer where to put the
result, and the table caption (a string), and then inserts the
generated table in the proper syntax into the destination buffer.  The
default destination buffer is `table.LANG', where LANG is the language
you specified.


File: emacs,  Node: Programs,  Next: Building,  Prev: Text,  Up: Top

30 Editing Programs
*******************

Emacs provides many features to facilitate editing programs.  Some of
these features can

   * Find or move over top-level definitions (*note Defuns::).

   * Apply the usual indentation conventions of the language (*note
     Program Indent::).

   * Balance parentheses (*note Parentheses::).

   * Insert, kill or align comments (*note Comments::).

   * Highlight program syntax (*note Font Lock::).

   This chapter describes these features and many more.

* Menu:

* Program Modes::       Major modes for editing programs.
* Defuns::              Commands to operate on major top-level parts
                          of a program.
* Program Indent::      Adjusting indentation to show the nesting.
* Parentheses::         Commands that operate on parentheses.
* Comments::	        Inserting, killing, and aligning comments.
* Documentation::       Getting documentation of functions you plan to call.
* Hideshow::            Displaying blocks selectively.
* Symbol Completion::   Completion on symbol names of your program or language.
* Glasses::             Making identifiersLikeThis more readable.
* Semantic::            Suite of editing tools based on source code parsing.
* Misc for Programs::   Other Emacs features useful for editing programs.
* C Modes::             Special commands of C, C++, Objective-C,
                          Java, and Pike modes.
* Asm Mode::            Asm mode and its special features.

* Fortran::             Fortran mode and its special features.


File: emacs,  Node: Program Modes,  Next: Defuns,  Up: Programs

30.1 Major Modes for Programming Languages
==========================================

Emacs has specialized major modes for various programming languages.
*Note Major Modes::.  A programming language major mode typically
specifies the syntax of expressions, the customary rules for
indentation, how to do syntax highlighting for the language, and how to
find the beginning or end of a function definition.  It often
customizes or provides facilities for compiling and debugging programs
as well.

   Ideally, Emacs should provide a major mode for each programming
language that you might want to edit; if it doesn't have a mode for
your favorite language, you can contribute one.  But often the mode for
one language can serve for other syntactically similar languages.  The
major mode for language L is called `L-mode', and you can select it by
typing `M-x L-mode <RET>'.  *Note Choosing Modes::.

   The existing programming language major modes include Lisp, Scheme
(a variant of Lisp) and the Scheme-based DSSSL expression language,
Ada, ASM, AWK, C, C++, Delphi (Object Pascal), Fortran, Icon, IDL
(CORBA), IDLWAVE, Java, Javascript, Metafont (TeX's companion for font
creation), Modula2, Objective-C, Octave, Pascal, Perl, Pike,
PostScript, Prolog, Python, Ruby, Simula, Tcl, and VHDL.  An
alternative mode for Perl is called CPerl mode.  Modes are available
for the scripting languages of the common GNU and Unix shells, VMS DCL,
and MS-DOS/MS-Windows `BAT' files.  There are also major modes for
editing makefiles, DNS master files, and various sorts of configuration
files.

   In most programming languages, indentation should vary from line to
line to illustrate the structure of the program.  So the major modes
for programming languages arrange for <TAB> to update the indentation
of the current line (*note Program Indent::).  They also rebind <DEL>
to treat a tab as if it were the equivalent number of spaces; this lets
you delete one column of indentation without worrying whether the
whitespace consists of spaces or tabs.  Use `C-b C-d' to delete a tab
character before point, in these modes.

   Separate manuals are available for the modes for Ada (*note Ada
Mode: (ada-mode)Top.), C/C++/Objective C/Java/Corba IDL/Pike/AWK (*note
CC Mode: (ccmode)Top.) and the IDLWAVE modes (*note IDLWAVE:
(idlwave)Top.).  For Fortran mode, see *note Fortran::.

   Turning on a major mode runs a normal hook called the "mode hook",
which is the value of a Lisp variable.  Each major mode has a mode
hook, and the hook's name is always made from the mode command's name
by adding `-hook'.  For example, turning on C mode runs the hook
`c-mode-hook', while turning on Lisp mode runs the hook
`lisp-mode-hook'.  The purpose of the mode hook is to give you a place
to set up customizations for that major mode.  *Note Hooks::.


File: emacs,  Node: Defuns,  Next: Program Indent,  Prev: Program Modes,  Up: Programs

30.2 Top-Level Definitions, or Defuns
=====================================

In Emacs, a major definition at the top level in the buffer, such as a
function, is called a "defun".  The name comes from Lisp, but in Emacs
we use it for all languages.

* Menu:

* Left Margin Paren::   An open-paren or similar opening delimiter
                          starts a defun if it is at the left margin.
* Moving by Defuns::    Commands to move over or mark a major definition.
* Imenu::               Making buffer indexes as menus.
* Which Function::      Which Function mode shows which function you are in.


File: emacs,  Node: Left Margin Paren,  Next: Moving by Defuns,  Up: Defuns

30.2.1 Left Margin Convention
-----------------------------

Many programming-language modes assume by default that any opening
delimiter found at the left margin is the start of a top-level
definition, or defun.  Therefore, *don't put an opening delimiter at
the left margin unless it should have that significance*.  For
instance, never put an open-parenthesis at the left margin in a Lisp
file unless it is the start of a top-level list.

   The convention speeds up many Emacs operations, which would
otherwise have to scan back to the beginning of the buffer to analyze
the syntax of the code.

   If you don't follow this convention, not only will you have trouble
when you explicitly use the commands for motion by defuns; other
features that use them will also give you trouble.  This includes the
indentation commands (*note Program Indent::) and Font Lock mode (*note
Font Lock::).

   The most likely problem case is when you want an opening delimiter
at the start of a line inside a string.  To avoid trouble, put an
escape character (`\', in C and Emacs Lisp, `/' in some other Lisp
dialects) before the opening delimiter.  This will not affect the
contents of the string, but will prevent that opening delimiter from
starting a defun.  Here's an example:

       (insert "Foo:
     \(bar)
     ")

   To help you catch violations of this convention, Font Lock mode
highlights confusing opening delimiters (those that ought to be quoted)
in bold red.

   If you need to override this convention, you can do so by setting
this user option:

 -- Variable: open-paren-in-column-0-is-defun-start
     If this user option is set to `t' (the default), opening
     parentheses or braces at column zero always start defuns.  When
     it's `nil', defuns are found by searching for parens or braces at
     the outermost level.

   Usually, you should leave this option at its default value of `t'.
If your buffer contains parentheses or braces in column zero which
don't start defuns, and it is somehow impractical to remove these
parentheses or braces, it might be helpful to set the option to `nil'.
Be aware that this might make scrolling and display in large buffers
quite sluggish.  Furthermore, the parentheses and braces must be
correctly matched throughout the buffer for it to work properly.


File: emacs,  Node: Moving by Defuns,  Next: Imenu,  Prev: Left Margin Paren,  Up: Defuns

30.2.2 Moving by Defuns
-----------------------

These commands move point or set up the region based on top-level major
definitions, also called "defuns".

`C-M-a'
     Move to beginning of current or preceding defun
     (`beginning-of-defun').

`C-M-e'
     Move to end of current or following defun (`end-of-defun').

`C-M-h'
     Put region around whole current or following defun (`mark-defun').

   The commands to move to the beginning and end of the current defun
are `C-M-a' (`beginning-of-defun') and `C-M-e' (`end-of-defun').  If
you repeat one of these commands, or use a positive numeric argument,
each repetition moves to the next defun in the direction of motion.

   `C-M-a' with a negative argument -N moves forward N times to the
next beginning of a defun.  This is not exactly the same place that
`C-M-e' with argument N would move to; the end of this defun is not
usually exactly the same place as the beginning of the following defun.
(Whitespace, comments, and perhaps declarations can separate them.)
Likewise, `C-M-e' with a negative argument moves back to an end of a
defun, which is not quite the same as `C-M-a' with a positive argument.

   To operate on the current defun, use `C-M-h' (`mark-defun'), which
sets the mark at the end of the current defun and puts point at its
beginning.  *Note Marking Objects::.  This is the easiest way to get
ready to kill the defun in order to move it to a different place in the
file.  If you use the command while point is between defuns, it uses
the following defun.  If you use the command while the mark is already
active, it sets the mark but does not move point; furthermore, each
successive use of `C-M-h' extends the end of the region to include one
more defun.

   In C mode, `C-M-h' runs the function `c-mark-function', which is
almost the same as `mark-defun'; the difference is that it backs up
over the argument declarations, function name and returned data type so
that the entire C function is inside the region.  This is an example of
how major modes adjust the standard key bindings so that they do their
standard jobs in a way better fitting a particular language.  Other
major modes may replace any or all of these key bindings for that
purpose.


File: emacs,  Node: Imenu,  Next: Which Function,  Prev: Moving by Defuns,  Up: Defuns

30.2.3 Imenu
------------

The Imenu facility offers a way to find the major definitions in a file
by name.  It is also useful in text formatter major modes, where it
treats each chapter, section, etc., as a definition.  (*Note Tags::,
for a more powerful feature that handles multiple files together.)

   If you type `M-x imenu', it reads the name of a definition using the
minibuffer, then moves point to that definition.  You can use
completion to specify the name; the command always displays the whole
list of valid names.

   Alternatively, you can bind the command `imenu' to a mouse click.
Then it displays mouse menus for you to select a definition name.  You
can also add the buffer's index to the menu bar by calling
`imenu-add-menubar-index'.  If you want to have this menu bar item
available for all buffers in a certain major mode, you can do this by
adding `imenu-add-menubar-index' to its mode hook.  But if you have
done that, you will have to wait a little while each time you visit a
file in that mode, while Emacs finds all the definitions in that buffer.

   When you change the contents of a buffer, if you add or delete
definitions, you can update the buffer's index based on the new
contents by invoking the `*Rescan*' item in the menu.  Rescanning
happens automatically if you set `imenu-auto-rescan' to a non-`nil'
value.  There is no need to rescan because of small changes in the text.

   You can customize the way the menus are sorted by setting the
variable `imenu-sort-function'.  By default, names are ordered as they
occur in the buffer; if you want alphabetic sorting, use the symbol
`imenu--sort-by-name' as the value.  You can also define your own
comparison function by writing Lisp code.

   Imenu provides the information to guide Which Function mode (*note
Which Function::).  The Speedbar can also use it (*note Speedbar::).


File: emacs,  Node: Which Function,  Prev: Imenu,  Up: Defuns

30.2.4 Which Function Mode
--------------------------

Which Function mode is a minor mode that displays the current function
name in the mode line, updating it as you move around in a buffer.

   To either enable or disable Which Function mode, use the command
`M-x which-function-mode'.  This command applies to all buffers, both
existing ones and those yet to be created.  However, it takes effect
only in certain major modes, those listed in the value of
`which-func-modes'.  If the value of `which-func-modes' is `t' rather
than a list of modes, then Which Function mode applies to all major
modes that know how to support it--in other words, all the major modes
that support Imenu.


File: emacs,  Node: Program Indent,  Next: Parentheses,  Prev: Defuns,  Up: Programs

30.3 Indentation for Programs
=============================

The best way to keep a program properly indented is to use Emacs to
reindent it as you change it.  Emacs has commands to indent either a
single line, a specified number of lines, or all of the lines inside a
single parenthetical grouping.

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C and related modes.
* Custom C Indent::	Controlling indentation style for C and related modes.

   Emacs also provides a Lisp pretty-printer in the library `pp'.  This
program reformats a Lisp object with indentation chosen to look nice.


File: emacs,  Node: Basic Indent,  Next: Multi-line Indent,  Up: Program Indent

30.3.1 Basic Program Indentation Commands
-----------------------------------------

The basic indentation commands indent a single line according to the
usual conventions of the language you are editing.

`<TAB>'
     Adjust indentation of current line.

`C-j'
     Insert a newline, then adjust indentation of following line
     (`newline-and-indent').

   The basic indentation command is <TAB>.  In any programming-language
major mode, <TAB> gives the current line the correct indentation as
determined from the previous lines.  It does this by inserting or
deleting whitespace at the beginning of the current line.  If point was
inside the whitespace at the beginning of the line, <TAB> puts it at
the end of that whitespace; otherwise, <TAB> keeps point fixed with
respect to the characters around it.  If the region is active (*note
Mark::), <TAB> indents every line within the region instead of just the
current line.  The function that <TAB> runs depends on the major mode;
for instance, it is `c-indent-line-or-region' in C mode.  Each function
is aware of the syntax and conventions for its particular language.

   Use `C-q <TAB>' to insert a tab character at point.

   When entering lines of new code, use `C-j' (`newline-and-indent'),
which inserts a newline and then adjusts indentation after it.  (It
also deletes any trailing whitespace which remains before the new
newline.)  For instance, `C-j' at the end of a line creates a blank
line with appropriate indentation.  In programming language modes, it
is equivalent to <RET> <TAB>.

   When Emacs indents a line that starts within a parenthetical
grouping, it usually places the start of the line under the preceding
line within the group, or under the text after the parenthesis.  If you
manually give one of these lines a nonstandard indentation, the lines
below will tend to follow it.  This behavior is convenient in cases
where you have overridden the standard result of <TAB> indentation
(e.g., for aesthetic purposes).

   Many programming-language modes assume that an open-parenthesis,
open-brace or other opening delimiter at the left margin is the start
of a function.  This assumption speeds up indentation commands.  If the
text you are editing contains opening delimiters in column zero that
aren't the beginning of a functions--even if these delimiters occur
inside strings or comments--then you must set
`open-paren-in-column-0-is-defun-start'.  *Note Left Margin Paren::.

   Normally, Emacs indents lines using an "optimal" mix of tab and
space characters.  If you want Emacs to use spaces only, set
`indent-tabs-mode' (*note Just Spaces::).


File: emacs,  Node: Multi-line Indent,  Next: Lisp Indent,  Prev: Basic Indent,  Up: Program Indent

30.3.2 Indenting Several Lines
------------------------------

Sometimes, you may want to reindent several lines of code at a time.
One way to do this is to use the mark; when the mark is active and the
region is non-empty, <TAB> indents every line within the region.  In
addition, Emacs provides several other commands for indenting large
chunks of code:

`C-M-q'
     Reindent all the lines within one parenthetical grouping.

`C-M-\'
     Reindent all lines in the region (`indent-region').

`C-u <TAB>'
     Shift an entire parenthetical grouping rigidly sideways so that its
     first line is properly indented.

`M-x indent-code-rigidly'
     Shift all the lines in the region rigidly sideways, but do not
     alter lines that start inside comments and strings.

   To reindent the contents of a single parenthetical grouping,
position point before the beginning of the grouping and type `C-M-q'.
This changes the relative indentation within the grouping, without
affecting its overall indentation (i.e., the indentation of the line
where the grouping starts).  The function that `C-M-q' runs depends on
the major mode; it is `indent-pp-sexp' in Lisp mode, `c-indent-exp' in
C mode, etc.  To correct the overall indentation as well, type <TAB>
first.

   `C-M-\' (`indent-region') applies <TAB> to the region.  This is
useful when Transient Mark mode is disabled (*note Persistent Mark::),
because in that case <TAB> does not act on the region.

   If you like the relative indentation within a grouping but not the
indentation of its first line, move point to that first line and type
`C-u <TAB>'.  In Lisp, C, and some other major modes, <TAB> with a
numeric argument reindents the current line as usual, then reindents by
the same amount all the lines in the parenthetical grouping starting on
the current line.  It is clever, though, and does not alter lines that
start inside strings.  Neither does it alter C preprocessor lines when
in C mode, but it does reindent any continuation lines that may be
attached to them.

   The command `M-x indent-code-rigidly' rigidly shifts all the lines
in the region sideways, like `indent-rigidly' does (*note Indentation
Commands::).  It doesn't alter the indentation of lines that start
inside a string, unless the region also starts inside that string.  The
prefix arg specifies the number of columns to indent.


File: emacs,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Program Indent

30.3.3 Customizing Lisp Indentation
-----------------------------------

The indentation pattern for a Lisp expression can depend on the function
called by the expression.  For each Lisp function, you can choose among
several predefined patterns of indentation, or define an arbitrary one
with a Lisp program.

   The standard pattern of indentation is as follows: the second line
of the expression is indented under the first argument, if that is on
the same line as the beginning of the expression; otherwise, the second
line is indented underneath the function name.  Each following line is
indented under the previous line whose nesting depth is the same.

   If the variable `lisp-indent-offset' is non-`nil', it overrides the
usual indentation pattern for the second line of an expression, so that
such lines are always indented `lisp-indent-offset' more columns than
the containing list.

   Certain functions override the standard pattern.  Functions whose
names start with `def' treat the second lines as the start of a "body",
by indenting the second line `lisp-body-indent' additional columns
beyond the open-parenthesis that starts the expression.

   You can override the standard pattern in various ways for individual
functions, according to the `lisp-indent-function' property of the
function name.  Normally you would use this for macro definitions and
specify it using the `declare' construct (*note Defining Macros:
(elisp)Defining Macros.).


File: emacs,  Node: C Indent,  Next: Custom C Indent,  Prev: Lisp Indent,  Up: Program Indent

30.3.4 Commands for C Indentation
---------------------------------

Here are special features for indentation in C mode and related modes:

`C-c C-q'
     Reindent the current top-level function definition or aggregate
     type declaration (`c-indent-defun').

`C-M-q'
     Reindent each line in the balanced expression that follows point
     (`c-indent-exp').  A prefix argument inhibits warning messages
     about invalid syntax.

`<TAB>'
     Reindent the current line, and/or in some cases insert a tab
     character (`c-indent-command').

     If `c-tab-always-indent' is `t', this command always reindents the
     current line and does nothing else.  This is the default.

     If that variable is `nil', this command reindents the current line
     only if point is at the left margin or in the line's indentation;
     otherwise, it inserts a tab (or the equivalent number of spaces,
     if `indent-tabs-mode' is `nil').

     Any other value (not `nil' or `t') means always reindent the line,
     and also insert a tab if within a comment or a string.

   To reindent the whole current buffer, type `C-x h C-M-\'.  This
first selects the whole buffer as the region, then reindents that
region.

   To reindent the current block, use `C-M-u C-M-q'.  This moves to the
front of the block and then reindents it all.


File: emacs,  Node: Custom C Indent,  Prev: C Indent,  Up: Program Indent

30.3.5 Customizing C Indentation
--------------------------------

C mode and related modes use a flexible mechanism for customizing
indentation.  C mode indents a source line in two steps: first it
classifies the line syntactically according to its contents and
context; second, it determines the indentation offset associated by
your selected "style" with the syntactic construct and adds this onto
the indentation of the "anchor statement".

`C-c . <RET> STYLE <RET>'
     Select a predefined style STYLE (`c-set-style').

   A "style" is a named collection of customizations that can be used
in C mode and the related modes.  *note Styles: (ccmode)Styles, for a
complete description.  Emacs comes with several predefined styles,
including `gnu', `k&r', `bsd', `stroustrup', `linux', `python', `java',
`whitesmith', `ellemtel', and `awk'.  Some of these styles are
primarily intended for one language, but any of them can be used with
any of the languages supported by these modes.  To find out what a
style looks like, select it and reindent some code, e.g., by typing
<C-M-q> at the start of a function definition.

   To choose a style for the current buffer, use the command `C-c .'.
Specify a style name as an argument (case is not significant).  This
command affects the current buffer only, and it affects only future
invocations of the indentation commands; it does not reindent the code
already in the buffer.  To reindent the whole buffer in the new style,
you can type `C-x h C-M-\'.

   You can also set the variable `c-default-style' to specify the
default style for various major modes.  Its value should be either the
style's name (a string) or an alist, in which each element specifies
one major mode and which indentation style to use for it.  For example,

     (setq c-default-style
           '((java-mode . "java") (awk-mode . "awk") (other . "gnu")))

specifies explicit choices for Java and AWK modes, and the default
`gnu' style for the other C-like modes.  (These settings are actually
the defaults.)  This variable takes effect when you select one of the
C-like major modes; thus, if you specify a new default style for Java
mode, you can make it take effect in an existing Java mode buffer by
typing `M-x java-mode' there.

   The `gnu' style specifies the formatting recommended by the GNU
Project for C; it is the default, so as to encourage use of our
recommended style.

   *Note Indentation Engine Basics: (ccmode)Indentation Engine Basics,
and *note Customizing Indentation: (ccmode)Customizing Indentation, for
more information on customizing indentation for C and related modes,
including how to override parts of an existing style and how to define
your own styles.


File: emacs,  Node: Parentheses,  Next: Comments,  Prev: Program Indent,  Up: Programs

30.4 Commands for Editing with Parentheses
==========================================

This section describes the commands and features that take advantage of
the parenthesis structure in a program, or help you keep it balanced.

   When talking about these facilities, the term "parenthesis" also
includes braces, brackets, or whatever delimiters are defined to match
in pairs.  The major mode controls which delimiters are significant,
through the syntax table (*note Syntax::).  In Lisp, only parentheses
count; in C, these commands apply to braces and brackets too.

   You can use `M-x check-parens' to find any unbalanced parentheses
and unbalanced string quotes in the buffer.

* Menu:

* Expressions::         Expressions with balanced parentheses.
* Moving by Parens::    Commands for moving up, down and across
                          in the structure of parentheses.
* Matching::	        Insertion of a close-delimiter flashes matching open.


File: emacs,  Node: Expressions,  Next: Moving by Parens,  Up: Parentheses

30.4.1 Expressions with Balanced Parentheses
--------------------------------------------

These commands deal with balanced expressions, also called "sexps"(1).

`C-M-f'
     Move forward over a balanced expression (`forward-sexp').

`C-M-b'
     Move backward over a balanced expression (`backward-sexp').

`C-M-k'
     Kill balanced expression forward (`kill-sexp').

`C-M-t'
     Transpose expressions (`transpose-sexps').

`C-M-@'
`C-M-<SPC>'
     Put mark after following expression (`mark-sexp').

   Each programming language major mode customizes the definition of
balanced expressions to suit that language.  Balanced expressions
typically include symbols, numbers, and string constants, as well as
any pair of matching delimiters and their contents.  Some languages
have obscure forms of expression syntax that nobody has bothered to
implement in Emacs.

   By convention, the keys for these commands are all Control-Meta
characters.  They usually act on expressions just as the corresponding
Meta characters act on words.  For instance, the command `C-M-b' moves
backward over a balanced expression, just as `M-b' moves back over a
word.

   To move forward over a balanced expression, use `C-M-f'
(`forward-sexp').  If the first significant character after point is an
opening delimiter (`(' in Lisp; `(', `[' or `{' in C), `C-M-f' moves
past the matching closing delimiter.  If the character begins a symbol,
string, or number, `C-M-f' moves over that.

   The command `C-M-b' (`backward-sexp') moves backward over a balanced
expression.  The detailed rules are like those above for `C-M-f', but
with directions reversed.  If there are prefix characters
(single-quote, backquote and comma, in Lisp) preceding the expression,
`C-M-b' moves back over them as well.  The balanced expression commands
move across comments as if they were whitespace, in most modes.

   `C-M-f' or `C-M-b' with an argument repeats that operation the
specified number of times; with a negative argument, it moves in the
opposite direction.

   Killing a whole balanced expression can be done with `C-M-k'
(`kill-sexp').  `C-M-k' kills the characters that `C-M-f' would move
over.

   A somewhat random-sounding command which is nevertheless handy is
`C-M-t' (`transpose-sexps'), which drags the previous balanced
expression across the next one.  An argument serves as a repeat count,
moving the previous expression over that many following ones.  A
negative argument drags the previous balanced expression backwards
across those before it (thus canceling out the effect of `C-M-t' with a
positive argument).  An argument of zero, rather than doing nothing,
transposes the balanced expressions ending at or after point and the
mark.

   To set the region around the next balanced expression in the buffer,
use `C-M-<SPC>' (`mark-sexp'), which sets mark at the same place that
`C-M-f' would move to.  `C-M-<SPC>' treats numeric arguments in the
same way as `C-M-f'; in particular, a negative argument puts the mark
at the beginning of the previous balanced expression.  The alias
`C-M-@' is equivalent to `C-M-<SPC>'.  While the mark is active, each
successive use of `C-M-<SPC>' extends the region by shifting the mark
by one sexp.

   In languages that use infix operators, such as C, it is not possible
to recognize all balanced expressions as such because there can be
multiple possibilities at a given position.  For example, C mode does
not treat `foo + bar' as a single expression, even though it _is_ one C
expression; instead, it recognizes `foo' as one expression and `bar' as
another, with the `+' as punctuation between them.  Both `foo + bar'
and `foo' are legitimate choices for "the expression following point"
when point is at the `f', so the expression commands must perforce
choose one or the other to operate on.  Note that `(foo + bar)' is
recognized as a single expression in C mode, because of the parentheses.

   ---------- Footnotes ----------

   (1) The word "sexp" is used to refer to an expression in Lisp.


File: emacs,  Node: Moving by Parens,  Next: Matching,  Prev: Expressions,  Up: Parentheses

30.4.2 Moving in the Parenthesis Structure
------------------------------------------

The Emacs commands for handling parenthetical groupings see nothing
except parentheses (or whatever characters must balance in the language
you are working with).  They ignore strings and comments (including any
parentheses within them) and ignore parentheses quoted by an escape
character.  They are mainly intended for editing programs, but can be
useful for editing any text that has parentheses.  They are sometimes
called "list" commands because in Lisp these groupings are lists.

   These commands assume that the starting point is not inside a string
or a comment.  Sometimes you can invoke them usefully from one of these
places (for example, when you have a parenthesised clause in a comment)
but this is unreliable.

`C-M-n'
     Move forward over a parenthetical group (`forward-list').

`C-M-p'
     Move backward over a parenthetical group (`backward-list').

`C-M-u'
     Move up in parenthesis structure (`backward-up-list').

`C-M-d'
     Move down in parenthesis structure (`down-list').

   The "list" commands `C-M-n' (`forward-list') and `C-M-p'
(`backward-list') move forward or backward over one (or N)
parenthetical groupings.

   `C-M-n' and `C-M-p' try to stay at the same level in the parenthesis
structure.  To move _up_ one (or N) levels, use `C-M-u'
(`backward-up-list').  `C-M-u' moves backward up past one unmatched
opening delimiter.  A positive argument serves as a repeat count; a
negative argument reverses the direction of motion, so that the command
moves forward and up one or more levels.

   To move _down_ in the parenthesis structure, use `C-M-d'
(`down-list').  In Lisp mode, where `(' is the only opening delimiter,
this is nearly the same as searching for a `('.  An argument specifies
the number of levels to go down.


File: emacs,  Node: Matching,  Prev: Moving by Parens,  Up: Parentheses

30.4.3 Automatic Display Of Matching Parentheses
------------------------------------------------

The Emacs parenthesis-matching feature is designed to show
automatically how parentheses (and other matching delimiters) match in
the text.  Whenever you type a self-inserting character that is a
closing delimiter, the cursor moves momentarily to the location of the
matching opening delimiter, provided that is on the screen.  If it is
not on the screen, Emacs displays some of the text near it in the echo
area.  Either way, you can tell which grouping you are closing off.

   If the opening delimiter and closing delimiter are mismatched--such
as in `[x)'--a warning message is displayed in the echo area.

   Three variables control parenthesis match display:

   `blink-matching-paren' turns the feature on or off: `nil' disables
it, but the default is `t' to enable match display.

   `blink-matching-delay' says how many seconds to leave the cursor on
the matching opening delimiter, before bringing it back to the real
location of point; the default is 1, but on some systems it is useful
to specify a fraction of a second.

   `blink-matching-paren-distance' specifies how many characters back
to search to find the matching opening delimiter.  If the match is not
found in that distance, scanning stops, and nothing is displayed.  This
is to prevent the scan for the matching delimiter from wasting lots of
time when there is no match.  The default is 102400.

   Show Paren mode provides a more powerful kind of automatic matching.
Whenever point is before an opening delimiter or after a closing
delimiter, both that delimiter and its opposite delimiter are
highlighted.  Use the command `M-x show-paren-mode' to enable or
disable this mode.

   Show Paren mode uses the faces `show-paren-match' and
`show-paren-mismatch' to highlight parentheses; you can customize them
to control how highlighting looks.  *Note Face Customization::.


File: emacs,  Node: Comments,  Next: Documentation,  Prev: Parentheses,  Up: Programs

30.5 Manipulating Comments
==========================

Because comments are such an important part of programming, Emacs
provides special commands for editing and inserting comments.  It can
also do spell checking on comments with Flyspell Prog mode (*note
Spelling::).

* Menu:

* Comment Commands::    Inserting, killing, and aligning comments.
* Multi-Line Comments:: Commands for adding and editing multi-line comments.
* Options for Comments::Customizing the comment features.


File: emacs,  Node: Comment Commands,  Next: Multi-Line Comments,  Up: Comments

30.5.1 Comment Commands
-----------------------

The commands in this table insert, kill and align comments:

`M-;'
     Insert or realign comment on current line; alternatively, comment
     or uncomment the region (`comment-dwim').

`C-u M-;'
     Kill comment on current line (`comment-kill').

`C-x ;'
     Set comment column (`comment-set-column').

`C-M-j'
`M-j'
     Like <RET> followed by inserting and aligning a comment
     (`comment-indent-new-line').  *Note Multi-Line Comments::.

`M-x comment-region'
`C-c C-c' (in C-like modes)
     Add or remove comment delimiters on all the lines in the region.

   The command to create or align a comment is `M-;' (`comment-dwim').
The word "dwim" is an acronym for "Do What I Mean"; it indicates that
this command can be used for many different jobs relating to comments,
depending on the situation where you use it.

   When a region is active, `M-;' either adds or removes comment
delimiters on each line of the region.  *Note Mark::.  If every line in
the region is a comment, it removes comment delimiters from each;
otherwise, it adds comment delimiters to each.  You can also use the
commands `comment-region' and `uncomment-region' to explicitly comment
or uncomment the text in the region (*note Multi-Line Comments::).  If
you supply a prefix argument to `M-;' when a region is active, that
specifies how many comment delimiters to add or how many to delete.

   If the region is not active, `M-;' inserts a new comment if there is
no comment already on the line.  The new comment is normally aligned at
a specific column called the "comment column"; if the text of the line
extends past the comment column, `M-;' aligns the comment start string
to a suitable boundary (usually, at least one space is inserted).  The
comment begins with the string Emacs thinks comments should start with
(the value of `comment-start'; see below).  Emacs places point after
that string, so you can insert the text of the comment right away.  If
the major mode has specified a string to terminate comments, `M-;'
inserts that string after point, to keep the syntax valid.

   You can also use `M-;' to align an existing comment.  If a line
already contains the comment-start string, `M-;' realigns it to the
conventional alignment and moves point after it.  (Exception: comments
starting in column 0 are not moved.)  Even when an existing comment is
properly aligned, `M-;' is still useful for moving directly to the
start of the text inside the comment.

   `C-u M-;' kills any comment on the current line, along with the
whitespace before it.  To reinsert the comment on another line, move to
the end of that line, do `C-y', and then do `M-;' to realign it.

   Note that `C-u M-;' is not a distinct key; it is `M-;'
(`comment-dwim') with a prefix argument.  That command is programmed so
that when it receives a prefix argument it calls `comment-kill'.
However, `comment-kill' is a valid command in its own right, and you
can bind it directly to a key if you wish.

   Some major modes have special rules for aligning certain kinds of
comments in certain contexts.  For example, in Lisp code, comments which
start with two semicolons are indented as if they were lines of code,
instead of at the comment column.  Comments which start with three
semicolons are supposed to start at the left margin and are often used
for sectioning purposes.  Emacs understands these conventions by
indenting a double-semicolon comment using <TAB>, and by not changing
the indentation of a triple-semicolon comment at all.

     ;; This function is just an example.
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;;  And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

   For C-like modes, you can configure the exact effect of `M-;' by
setting the variables `c-indent-comment-alist' and
`c-indent-comments-syntactically-p'.  For example, on a line ending in
a closing brace, `M-;' puts the comment one space after the brace
rather than at `comment-column'.  For full details see *note Comment
Commands: (ccmode)Comment Commands.


File: emacs,  Node: Multi-Line Comments,  Next: Options for Comments,  Prev: Comment Commands,  Up: Comments

30.5.2 Multiple Lines of Comments
---------------------------------

If you are typing a comment and wish to continue it on another line,
you can use the command `C-M-j' or `M-j' (`comment-indent-new-line').
If `comment-multi-line' (*note Options for Comments::) is non-`nil', it
moves to a new line within the comment.  Otherwise it closes the
comment and starts a new comment on a new line.  When Auto Fill mode is
on, going past the fill column while typing a comment causes the
comment to be continued in just this fashion.

   To turn existing lines into comment lines, use the `M-x
comment-region' command (or type `C-c C-c' in C-like modes).  It adds
comment delimiters to the lines that start in the region, thus
commenting them out.  With a negative argument, it does the
opposite--it deletes comment delimiters from the lines in the region.

   With a positive argument, `comment-region' duplicates the last
character of the comment start sequence it adds; the argument specifies
how many copies of the character to insert.  Thus, in Lisp mode, `C-u 2
M-x comment-region' adds `;;' to each line.  Duplicating the comment
delimiter is a way of calling attention to the comment.  It can also
affect how the comment is aligned or indented.  In Lisp, for proper
indentation, you should use an argument of two or three, if between
defuns; if within a defun, it must be three.

   You can configure C Mode such that when you type a `/' at the start
of a line in a multi-line block comment, this closes the comment.
Enable the `comment-close-slash' clean-up for this.  *Note Clean-ups:
(ccmode)Clean-ups.


File: emacs,  Node: Options for Comments,  Prev: Multi-Line Comments,  Up: Comments

30.5.3 Options Controlling Comments
-----------------------------------

The "comment column", the column at which Emacs tries to place
comments, is stored in the variable `comment-column'.  You can set it
to a number explicitly.  Alternatively, the command `C-x ;'
(`comment-set-column') sets the comment column to the column point is
at.  `C-u C-x ;' sets the comment column to match the last comment
before point in the buffer, and then does a `M-;' to align the current
line's comment under the previous one.

   The variable `comment-column' is per-buffer: setting the variable in
the normal fashion affects only the current buffer, but there is a
default value which you can change with `setq-default'.  *Note
Locals::.  Many major modes initialize this variable for the current
buffer.

   The comment commands recognize comments based on the regular
expression that is the value of the variable `comment-start-skip'.
Make sure this regexp does not match the null string.  It may match more
than the comment starting delimiter in the strictest sense of the word;
for example, in C mode the value of the variable is
`"/\\*+ *\\|//+ *"', which matches extra stars and spaces after the
`/*' itself, and accepts C++ style comments also.  (Note that `\\' is
needed in Lisp syntax to include a `\' in the string, which is needed
to deny the first star its special meaning in regexp syntax.  *Note
Regexp Backslash::.)

   When a comment command makes a new comment, it inserts the value of
`comment-start' to begin it.  The value of `comment-end' is inserted
after point, so that it will follow the text that you will insert into
the comment.  When `comment-end' is non-empty, it should start with a
space.  For example, in C mode, `comment-start' has the value `"/* "'
and `comment-end' has the value `" */"'.

   The variable `comment-padding' specifies how many spaces
`comment-region' should insert on each line between the comment
delimiter and the line's original text.  The default is 1, to insert
one space.  `nil' means 0.  Alternatively, `comment-padding' can hold
the actual string to insert.

   The variable `comment-multi-line' controls how `C-M-j'
(`indent-new-comment-line') behaves when used inside a comment.
Specifically, when `comment-multi-line' is `nil', the command inserts a
comment terminator, begins a new line, and finally inserts a comment
starter.  Otherwise it does not insert the terminator and starter, so
it effectively continues the current comment across multiple lines.  In
languages that allow multi-line comments, the choice of value for this
variable is a matter of taste.  The default for this variable depends
on the major mode.

   The variable `comment-indent-function' should contain a function
that will be called to compute the alignment for a newly inserted
comment or for aligning an existing comment.  It is set differently by
various major modes.  The function is called with no arguments, but with
point at the beginning of the comment, or at the end of a line if a new
comment is to be inserted.  It should return the column in which the
comment ought to start.  For example, in Lisp mode, the indent hook
function bases its decision on how many semicolons begin an existing
comment, and on the code in the preceding lines.


File: emacs,  Node: Documentation,  Next: Hideshow,  Prev: Comments,  Up: Programs

30.6 Documentation Lookup
=========================

Emacs provides several features you can use to look up the
documentation of functions, variables and commands that you plan to use
in your program.

* Menu:

* Info Lookup::         Looking up library functions and commands
                          in Info files.
* Man Page::            Looking up man pages of library functions and commands.
* Lisp Doc::            Looking up Emacs Lisp functions, etc.


File: emacs,  Node: Info Lookup,  Next: Man Page,  Up: Documentation

30.6.1 Info Documentation Lookup
--------------------------------

For major modes that apply to languages which have documentation in
Info, you can use `C-h S' (`info-lookup-symbol') to view the Info
documentation for a symbol used in the program.  You specify the symbol
with the minibuffer; the default is the symbol appearing in the buffer
at point.  For example, in C mode this looks for the symbol in the C
Library Manual.  The command only works if the appropriate manual's
Info files are installed.

   The major mode determines where to look for documentation for the
symbol--which Info files to look in, and which indices to search.  You
can also use `M-x info-lookup-file' to look for documentation for a
file name.

   If you use `C-h S' in a major mode that does not support it, it asks
you to specify the "symbol help mode."  You should enter a command such
as `c-mode' that would select a major mode which `C-h S' does support.


File: emacs,  Node: Man Page,  Next: Lisp Doc,  Prev: Info Lookup,  Up: Documentation

30.6.2 Man Page Lookup
----------------------

On Unix, the main form of on-line documentation was the "manual page"
or "man page".  In the GNU operating system, we aim to replace man
pages with better-organized manuals that you can browse with Info
(*note Misc Help::).  This process is not finished, so it is still
useful to read manual pages.

   You can read the man page for an operating system command, library
function, or system call, with the `M-x man' command.  It runs the
`man' program to format the man page; if the system permits, it runs
`man' asynchronously, so that you can keep on editing while the page is
being formatted.  (On MS-DOS and MS-Windows 3, you cannot edit while
Emacs waits for `man' to finish.)  The result goes in a buffer named
`*Man TOPIC*'.  These buffers use a special major mode, Man mode, that
facilitates scrolling and jumping to other manual pages.  For details,
type `C-h m' while in a man page buffer.

   Each man page belongs to one of ten or more "sections", each named
by a digit or by a digit and a letter.  Sometimes there are multiple
man pages with the same name in different sections.  To read a man page
from a specific section, type `TOPIC(SECTION)' or `SECTION TOPIC' when
`M-x manual-entry' prompts for the topic.  For example, to read the man
page for the C library function `chmod' (as opposed to a command of the
same name), type `M-x manual-entry <RET> chmod(2) <RET>'.  (`chmod' is
a system call, so it is in section `2'.)

   If you do not specify a section, the results depend on how the `man'
program works on your system.  Some of them display only the first man
page they find.  Others display all man pages that have the specified
name, so you can move between them with the `M-n' and `M-p' keys(1).
The mode line shows how many manual pages are present in the Man buffer.

   By default, Emacs highlights the text in man pages.  For a long man
page, highlighting can take substantial time.  You can turn off
highlighting of man pages by setting the variable
`Man-fontify-manpage-flag' to `nil'.

   If you insert the text of a man page into an Emacs buffer in some
other fashion, you can use the command `M-x Man-fontify-manpage' to
perform the same conversions that `M-x manual-entry' does.

   An alternative way of reading manual pages is the `M-x woman'
command(2).  Unlike `M-x man', it does not run any external programs to
format and display the man pages; instead it does the job in Emacs
Lisp, so it works on systems such as MS-Windows, where the `man'
program (and other programs it uses) are not generally available.

   `M-x woman' prompts for a name of a manual page, and provides
completion based on the list of manual pages that are installed on your
machine; the list of available manual pages is computed automatically
the first time you invoke `woman'.  The word at point in the current
buffer is used to suggest the default for the name of the manual page.

   With a numeric argument, `M-x woman' recomputes the list of the
manual pages used for completion.  This is useful if you add or delete
manual pages.

   If you type a name of a manual page and `M-x woman' finds that
several manual pages by the same name exist in different sections, it
pops up a window with possible candidates asking you to choose one of
them.

   For more information about setting up and using `M-x woman', see
*note WoMan: (woman)Top.

   ---------- Footnotes ----------

   (1) On some systems, the `man' program accepts a `-a' command-line
option which tells it to display all the man pages for the specified
topic.  If you want this behavior, you can add this option to the value
of the variable `Man-switches'.

   (2) The name of the command, `woman', is an acronym for "w/o
(without) man," since it doesn't use the `man' program.


File: emacs,  Node: Lisp Doc,  Prev: Man Page,  Up: Documentation

30.6.3 Emacs Lisp Documentation Lookup
--------------------------------------

As you edit Lisp code to be run in Emacs, you can use the commands `C-h
f' (`describe-function') and `C-h v' (`describe-variable') to view
documentation of functions and variables that you want to use.  These
commands use the minibuffer to read the name of a function or variable
to document, and display the documentation in a window.  Their default
arguments are based on the code in the neighborhood of point.  For `C-h
f', the default is the function called in the innermost list containing
point.  `C-h v' uses the symbol name around or adjacent to point as its
default.

   A more automatic but less powerful method is Eldoc mode.  This minor
mode constantly displays in the echo area the argument list for the
function being called at point.  (In other words, it finds the function
call that point is contained in, and displays the argument list of that
function.)  If point is over a documented variable, it shows the first
line of the variable's docstring.  Eldoc mode applies in Emacs Lisp and
Lisp Interaction modes, and perhaps a few others that provide special
support for looking up doc strings.  Use the command `M-x eldoc-mode'
to enable or disable this feature.


File: emacs,  Node: Hideshow,  Next: Symbol Completion,  Prev: Documentation,  Up: Programs

30.7 Hideshow minor mode
========================

Hideshow minor mode provides selective display of portions of a
program, known as "blocks".  You can use `M-x hs-minor-mode' to enable
or disable this mode, or add `hs-minor-mode' to the mode hook for
certain major modes in order to enable it automatically for those modes.

   Just what constitutes a block depends on the major mode.  In C mode
or C++ mode, they are delimited by braces, while in Lisp mode and
similar modes they are delimited by parentheses.  Multi-line comments
also count as blocks.

`C-c @ C-h'
     Hide the current block (`hs-hide-block').

`C-c @ C-s'
     Show the current block (`hs-show-block').

`C-c @ C-c'
     Either hide or show the current block (`hs-toggle-hiding').

`S-Mouse-2'
     Either hide or show the block you click on
     (`hs-mouse-toggle-hiding').

`C-c @ C-M-h'
     Hide all top-level blocks (`hs-hide-all').

`C-c @ C-M-s'
     Show everything in the buffer (`hs-show-all').

`C-c @ C-l'
     Hide all blocks N levels below this block (`hs-hide-level').

   These variables exist for customizing Hideshow mode.

`hs-hide-comments-when-hiding-all'
     Non-`nil' says that `hs-hide-all' should hide comments too.

`hs-isearch-open'
     Specifies what kind of hidden blocks incremental search should make
     visible.  The value should be one of these four symbols:

    `code'
          Open only code blocks.

    `comment'
          Open only comments.

    `t'
          Open both code blocks and comments.

    `nil'
          Open neither code blocks nor comments.

`hs-special-modes-alist'
     A list of elements, each specifying how to initialize Hideshow
     variables for one major mode.  See the variable's documentation
     string for more information.


File: emacs,  Node: Symbol Completion,  Next: Glasses,  Prev: Hideshow,  Up: Programs

30.8 Completion for Symbol Names
================================

In Emacs, completion is something you normally do in the minibuffer
(*note Completion::).  But one kind of completion is available in all
buffers: completion for symbol names.

   The character `M-<TAB>' runs a command to complete the partial
symbol before point against the set of meaningful symbol names.  This
command inserts at point any additional characters that it can
determine from the partial name.

   If your window manager defines `M-<TAB>' to switch windows, you can
type `<ESC> <TAB>' or `C-M-i' instead.  However, most window managers
let you customize these shortcuts, so you can change any that interfere
with the way you use Emacs.

   If the partial name in the buffer has multiple possible completions
that differ in the very next character, so that it is impossible to
complete even one more character, `M-<TAB>' displays a list of all
possible completions in another window.

   In most programming language major modes, `M-<TAB>' runs the command
`complete-symbol', which provides two kinds of completion.  Normally it
does completion based on a tags table (*note Tags::); with a numeric
argument (regardless of the value), it does completion based on the
names listed in the Info file indexes for your language.  Thus, to
complete the name of a symbol defined in your own program, use
`M-<TAB>' with no argument; to complete the name of a standard library
function, use `C-u M-<TAB>'.  Of course, Info-based completion works
only if there is an Info file for the standard library functions of
your language, and only if it is installed at your site.

   In Emacs-Lisp mode, the name space for completion normally consists
of nontrivial symbols present in Emacs--those that have function
definitions, values or properties.  However, if there is an
open-parenthesis immediately before the beginning of the partial symbol,
only symbols with function definitions are considered as completions.
The command which implements this is `lisp-complete-symbol'.

   In Text mode and related modes, `M-<TAB>' completes words based on
the spell-checker's dictionary.  *Note Spelling::.


File: emacs,  Node: Glasses,  Next: Semantic,  Prev: Symbol Completion,  Up: Programs

30.9 Glasses minor mode
=======================

Glasses minor mode makes `unreadableIdentifiersLikeThis' readable by
altering the way they display.  It knows two different ways to do this:
by displaying underscores between a lower-case letter and the following
capital letter, and by emboldening the capital letters.  It does not
alter the buffer text, only the way they display, so you can use it
even on read-only buffers.  You can use the command `M-x glasses-mode'
to enable or disable the mode in the current buffer; you can also add
`glasses-mode' to the mode hook of the programming language major modes
in which you normally want to use Glasses mode.


File: emacs,  Node: Semantic,  Next: Misc for Programs,  Prev: Glasses,  Up: Programs

30.10 Semantic
==============

Semantic is a package that provides language-aware editing commands
based on `source code parsers'.  This section provides a brief
description of Semantic; for full details, see *note Semantic:
(semantic)Top.

   Most of the "language aware" features in Emacs, such as font lock
(*note Font Lock::), rely on "rules of thumb"(1) that usually give good
results but are never completely exact.  In contrast, the parsers used
by Semantic have an exact understanding of programming language syntax.
This allows Semantic to provide search, navigation, and completion
commands that are powerful and precise.

   To begin using Semantic, type `M-x semantic-mode' or click on the
menu item named `Source Code Parsers (Semantic)' in the `Tools' menu.
This enables Semantic mode, a global minor mode.

   When Semantic mode is enabled, Emacs automatically attempts to
parses each file you visit.  Currently, Semantic understands C, C++,
Scheme, Javascript, Java, HTML, and Make.  Within each parsed buffer,
the following commands are available:

`C-c , j'
     Prompt for the name of a function defined in the current file, and
     move point there (`semantic-complete-jump-local').

`C-c , J'
     Prompt for the name of a function defined in any file Emacs has
     parsed, and move point there (`semantic-complete-jump').

`C-c , <SPC>'
     Display a list of possible completions for the symbol at point
     (`semantic-complete-analyze-inline').  This also activates a set
     of special keybindings for choosing a completion: <RET> accepts
     the current completion, `M-n' and `M-p' cycle through possible
     completions, <TAB> completes as far as possible and then cycles,
     and `C-g' or any other key aborts completion.

`C-c , l'
     Display a list of the possible completions of the symbol at point,
     in another window (`semantic-analyze-possible-completions').

In addition to the above commands, the Semantic package provides a
variety of other ways to make use of parser information.  For instance,
you can use it to display a list of completions when Emacs is idle.
*Note Semantic: (semantic)Top, for details.

   ---------- Footnotes ----------

   (1) Regular expressions and syntax tables.


File: emacs,  Node: Misc for Programs,  Next: C Modes,  Prev: Semantic,  Up: Programs

30.11 Other Features Useful for Editing Programs
================================================

A number of Emacs commands that aren't designed specifically for
editing programs are useful for that nonetheless.

   The Emacs commands that operate on words, sentences and paragraphs
are useful for editing code.  Most symbols names contain words (*note
Words::); sentences can be found in strings and comments (*note
Sentences::).  Paragraphs in the strict sense can be found in program
code (in long comments), but the paragraph commands are useful in other
places too, because programming language major modes define paragraphs
to begin and end at blank lines (*note Paragraphs::).  Judicious use of
blank lines to make the program clearer will also provide useful chunks
of text for the paragraph commands to work on.  Auto Fill mode, if
enabled in a programming language major mode, indents the new lines
which it creates.

   The selective display feature is useful for looking at the overall
structure of a function (*note Selective Display::).  This feature
hides the lines that are indented more than a specified amount.
Programming modes often support Outline minor mode (*note Outline
Mode::).  The Foldout package provides folding-editor features (*note
Foldout::).

   The "automatic typing" features may be useful for writing programs.
*Note Autotyping: (autotype)Top.


File: emacs,  Node: C Modes,  Next: Asm Mode,  Prev: Misc for Programs,  Up: Programs

30.12 C and Related Modes
=========================

This section gives a brief description of the special features
available in C, C++, Objective-C, Java, CORBA IDL, Pike and AWK modes.
(These are called "C mode and related modes.")  *Note CC Mode:
(ccmode)Top, for a more extensive description of these modes and their
special features.

* Menu:

* Motion in C::                 Commands to move by C statements, etc.
* Electric C::                  Colon and other chars can automatically reindent.
* Hungry Delete::               A more powerful DEL command.
* Other C Commands::            Filling comments, viewing expansion of macros,
                                and other neat features.


File: emacs,  Node: Motion in C,  Next: Electric C,  Up: C Modes

30.12.1 C Mode Motion Commands
------------------------------

This section describes commands for moving point, in C mode and related
modes.

`M-x c-beginning-of-defun'
`M-x c-end-of-defun'
     Move point to the beginning or end of the current function or
     top-level definition.  These are found by searching for the least
     enclosing braces.  (By contrast, `beginning-of-defun' and
     `end-of-defun' search for braces in column zero.)  If you are
     editing code where the opening brace of a function isn't placed in
     column zero, you may wish to bind `C-M-a' and `C-M-e' to these
     commands.  *Note Moving by Defuns::.

`C-c C-u'
     Move point back to the containing preprocessor conditional,
     leaving the mark behind.  A prefix argument acts as a repeat
     count.  With a negative argument, move point forward to the end of
     the containing preprocessor conditional.

     `#elif' is equivalent to `#else' followed by `#if', so the
     function will stop at a `#elif' when going backward, but not when
     going forward.

`C-c C-p'
     Move point back over a preprocessor conditional, leaving the mark
     behind.  A prefix argument acts as a repeat count.  With a negative
     argument, move forward.

`C-c C-n'
     Move point forward across a preprocessor conditional, leaving the
     mark behind.  A prefix argument acts as a repeat count.  With a
     negative argument, move backward.

`M-a'
     Move point to the beginning of the innermost C statement
     (`c-beginning-of-statement').  If point is already at the beginning
     of a statement, move to the beginning of the preceding statement.
     With prefix argument N, move back N - 1 statements.

     In comments or in strings which span more than one line, this
     command moves by sentences instead of statements.

`M-e'
     Move point to the end of the innermost C statement or sentence;
     like `M-a' except that it moves in the other direction
     (`c-end-of-statement').


File: emacs,  Node: Electric C,  Next: Hungry Delete,  Prev: Motion in C,  Up: C Modes

30.12.2 Electric C Characters
-----------------------------

In C mode and related modes, certain printing characters are
"electric"--in addition to inserting themselves, they also reindent the
current line, and optionally also insert newlines.  The "electric"
characters are `{', `}', `:', `#', `;', `,', `<', `>', `/', `*', `(',
and `)'.

   You might find electric indentation inconvenient if you are editing
chaotically indented code.  If you are new to CC Mode, you might find
it disconcerting.  You can toggle electric action with the command `C-c
C-l'; when it is enabled, `/l' appears in the mode line after the mode
name:

`C-c C-l'
     Toggle electric action (`c-toggle-electric-state').  With a prefix
     argument, this command enables electric action if the argument is
     positive, disables it if it is negative.

   Electric characters insert newlines only when, in addition to the
electric state, the "auto-newline" feature is enabled (indicated by
`/la' in the mode line after the mode name).  You can turn this feature
on or off with the command `C-c C-a':

`C-c C-a'
     Toggle the auto-newline feature (`c-toggle-auto-newline').  With a
     prefix argument, this command turns the auto-newline feature on if
     the argument is positive, and off if it is negative.

   Usually the CC Mode style configures the exact circumstances in
which Emacs inserts auto-newlines.  You can also configure this
directly.  *Note Custom Auto-newlines: (ccmode)Custom Auto-newlines.


File: emacs,  Node: Hungry Delete,  Next: Other C Commands,  Prev: Electric C,  Up: C Modes

30.12.3 Hungry Delete Feature in C
----------------------------------

If you want to delete an entire block of whitespace at point, you can
use "hungry deletion".  This deletes all the contiguous whitespace
either before point or after point in a single operation.  "Whitespace"
here includes tabs and newlines, but not comments or preprocessor
commands.

`C-c C-<DEL>'
`C-c <DEL>'
     `c-hungry-delete-backwards'--Delete the entire block of whitespace
     preceding point.

`C-c C-d'
`C-c C-<DELETE>'
`C-c <DELETE>'
     `c-hungry-delete-forward'--Delete the entire block of whitespace
     following point.

   As an alternative to the above commands, you can enable "hungry
delete mode".  When this feature is enabled (indicated by `/h' in the
mode line after the mode name), a single <DEL> deletes all preceding
whitespace, not just one space, and a single `C-c C-d' (but _not_ plain
<DELETE>) deletes all following whitespace.

`M-x c-toggle-hungry-state'
     Toggle the hungry-delete feature (`c-toggle-hungry-state')(1).
     With a prefix argument, this command turns the hungry-delete
     feature on if the argument is positive, and off if it is negative.

   The variable `c-hungry-delete-key' controls whether the
hungry-delete feature is enabled.

   ---------- Footnotes ----------

   (1) This command had the binding `C-c C-d' in earlier versions of
Emacs.  `C-c C-d' is now bound to `c-hungry-delete-forward'.


File: emacs,  Node: Other C Commands,  Prev: Hungry Delete,  Up: C Modes

30.12.4 Other Commands for C Mode
---------------------------------

`C-c C-w'
`M-x subword-mode'
     Enable (or disable) "subword mode".  In subword mode, Emacs's word
     commands recognize upper case letters in `StudlyCapsIdentifiers'
     as word boundaries.  This is indicated by the flag `/w' on the
     mode line after the mode name (e.g. `C/law').  You can even use
     `M-x subword-mode' in non-CC Mode buffers.

     In the GNU project, we recommend using underscores to separate
     words within an identifier in C or C++, rather than using case
     distinctions.

`M-x c-context-line-break'
     This command inserts a line break and indents the new line in a
     manner appropriate to the context.  In normal code, it does the
     work of `C-j' (`newline-and-indent'), in a C preprocessor line it
     additionally inserts a `\' at the line break, and within comments
     it's like `M-j' (`c-indent-new-comment-line').

     `c-context-line-break' isn't bound to a key by default, but it
     needs a binding to be useful.  The following code will bind it to
     `C-j'.  We use `c-initialization-hook' here to make sure the
     keymap is loaded before we try to change it.

          (defun my-bind-clb ()
            (define-key c-mode-base-map "\C-j" 'c-context-line-break))
          (add-hook 'c-initialization-hook 'my-bind-clb)

`C-M-h'
     Put mark at the end of a function definition, and put point at the
     beginning (`c-mark-function').

`M-q'
     Fill a paragraph, handling C and C++ comments (`c-fill-paragraph').
     If any part of the current line is a comment or within a comment,
     this command fills the comment or the paragraph of it that point
     is in, preserving the comment indentation and comment delimiters.

`C-c C-e'
     Run the C preprocessor on the text in the region, and show the
     result, which includes the expansion of all the macro calls
     (`c-macro-expand').  The buffer text before the region is also
     included in preprocessing, for the sake of macros defined there,
     but the output from this part isn't shown.

     When you are debugging C code that uses macros, sometimes it is
     hard to figure out precisely how the macros expand.  With this
     command, you don't have to figure it out; you can see the
     expansions.

`C-c C-\'
     Insert or align `\' characters at the ends of the lines of the
     region (`c-backslash-region').  This is useful after writing or
     editing a C macro definition.

     If a line already ends in `\', this command adjusts the amount of
     whitespace before it.  Otherwise, it inserts a new `\'.  However,
     the last line in the region is treated specially; no `\' is
     inserted on that line, and any `\' there is deleted.

`M-x cpp-highlight-buffer'
     Highlight parts of the text according to its preprocessor
     conditionals.  This command displays another buffer named `*CPP
     Edit*', which serves as a graphic menu for selecting how to
     display particular kinds of conditionals and their contents.
     After changing various settings, click on `[A]pply these settings'
     (or go to that buffer and type `a') to rehighlight the C mode
     buffer accordingly.

`C-c C-s'
     Display the syntactic information about the current source line
     (`c-show-syntactic-information').  This information directs how
     the line is indented.

`M-x cwarn-mode'
`M-x global-cwarn-mode'
     CWarn minor mode highlights certain suspicious C and C++
     constructions:

        * Assignments inside expressions.

        * Semicolon following immediately after `if', `for', and `while'
          (except after a `do ... while' statement);

        * C++ functions with reference parameters.

     You can enable the mode for one buffer with the command `M-x
     cwarn-mode', or for all suitable buffers with the command `M-x
     global-cwarn-mode' or by customizing the variable
     `global-cwarn-mode'.  You must also enable Font Lock mode to make
     it work.

`M-x hide-ifdef-mode'
     Hide-ifdef minor mode hides selected code within `#if' and
     `#ifdef' preprocessor blocks.  If you change the variable
     `hide-ifdef-shadow' to `t', Hide-ifdef minor mode "shadows"
     preprocessor blocks by displaying them with a less prominent face,
     instead of hiding them entirely.  See the documentation string of
     `hide-ifdef-mode' for more information.

`M-x ff-find-related-file'
     Find a file "related" in a special way to the file visited by the
     current buffer.  Typically this will be the header file
     corresponding to a C/C++ source file, or vice versa.  The variable
     `ff-related-file-alist' specifies how to compute related file
     names.


File: emacs,  Node: Asm Mode,  Next: Fortran,  Prev: C Modes,  Up: Programs

30.13 Asm Mode
==============

Asm mode is a major mode for editing files of assembler code.  It
defines these commands:

`<TAB>'
     `tab-to-tab-stop'.

`C-j'
     Insert a newline and then indent using `tab-to-tab-stop'.

`:'
     Insert a colon and then remove the indentation from before the
     label preceding colon.  Then do `tab-to-tab-stop'.

`;'
     Insert or align a comment.

   The variable `asm-comment-char' specifies which character starts
comments in assembler syntax.


File: emacs,  Node: Fortran,  Prev: Asm Mode,  Up: Programs

30.14 Fortran Mode
==================

Fortran mode is meant for editing "fixed form" (and also "tab format")
source code (normally Fortran 77).  For editing more modern "free form"
source code (Fortran 90, 95, 2003), use F90 mode (`f90-mode').  Emacs
normally uses Fortran mode for files with extension `.f', `.F' or
`.for', and F90 mode for the extensions `.f90' and `.f95'.  Customize
`auto-mode-alist' to add more extensions.  GNU Fortran supports both
free and fixed form.  This manual mainly documents Fortran mode, but
the corresponding F90 mode features are mentioned when revelant.

   Fortran mode provides special motion commands for Fortran statements
and subprograms, and indentation commands that understand Fortran
conventions of nesting, line numbers and continuation statements.
Fortran mode has support for Auto Fill mode that breaks long lines into
proper Fortran continuation lines.  Fortran mode also supports Hideshow
minor mode (*note Hideshow::), and Imenu (*note Imenu::).

   Special commands for comments are provided because Fortran comments
are unlike those of other languages.  Built-in abbrevs optionally save
typing when you insert Fortran keywords.

   Use `M-x fortran-mode' to switch to this major mode.  This command
runs the hook `fortran-mode-hook'.  *Note Hooks::.

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill support for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.


File: emacs,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

30.14.1 Motion Commands
-----------------------

In addition to the normal commands for moving by and operating on
"defuns" (Fortran subprograms--functions and subroutines, using the
commands `fortran-beginning-of-subprogram' and
`fortran-end-of-subprogram'; as well as modules for F90 mode), Fortran
mode provides special commands to move by statements and other program
units.

`C-c C-n'
     Move to the beginning of the next statement
     (`fortran-next-statement'/`f90-next-statement').

`C-c C-p'
     Move to the beginning of the previous statement
     (`fortran-previous-statement'/`f90-previous-statement').  If there
     is no previous statement (i.e. if called from the first statement
     in the buffer), move to the start of the buffer.

`C-c C-e'
     Move point forward to the start of the next code block, or the end
     of the current block, whichever is encountered first.
     (`f90-next-block').  A code block is a subroutine, `if'-`endif'
     statement, and so forth.  This command exists for F90 mode only,
     not Fortran mode.  With a numeric argument, this moves forward
     that many blocks.

`C-c C-a'
     Move point backward to the previous code block
     (`f90-previous-block').  This is like `f90-next-block', but moves
     backwards.

`C-M-n'
     Move to the end of the current code block
     (`fortran-end-of-block'/`f90-end-of-block').  With a numeric
     argument, move forward that number of blocks.  The mark is set
     before moving point.  The F90 mode version of this command checks
     for consistency of block types and labels (if present), but it
     does not check the outermost block since that may be incomplete.

`C-M-p'
     Move to the start of the current code block
     (`fortran-beginning-of-block'/`f90-beginning-of-block'). This is
     like `fortran-end-of-block', but moves backwards.

   The commands `fortran-beginning-of-subprogram' and
`fortran-end-of-subprogram' move to the start or end of the current
subprogram, respectively.  The commands `fortran-mark-do' and
`fortran-mark-if' mark the end of the current `do' or `if' block, and
move point to the start.


File: emacs,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

30.14.2 Fortran Indentation
---------------------------

Special commands and features are needed for indenting fixed (or tab)
form Fortran code in order to make sure various syntactic entities (line
numbers, comment line indicators and continuation line flags) appear in
the required columns.

* Menu:

* Commands: ForIndent Commands.  Commands for indenting and filling Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.


File: emacs,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

30.14.2.1 Fortran Indentation and Filling Commands
..................................................

`C-M-j'
     Break the current line at point and set up a continuation line
     (`fortran-split-line').

`M-^'
     Join this line to the previous line (`fortran-join-line').

`C-M-q'
     Indent all the lines of the subprogram point is in
     (`fortran-indent-subprogram').

`M-q'
     Fill a comment block or statement (using `fortran-fill-paragraph'
     or `fortran-fill-statement').

   The key `C-M-q' runs `fortran-indent-subprogram', a command to
reindent all the lines of the Fortran subprogram (function or
subroutine) containing point.

   The key `C-M-j' runs `fortran-split-line', which splits a line in
the appropriate fashion for Fortran.  In a non-comment line, the second
half becomes a continuation line and is indented accordingly.  In a
comment line, both halves become separate comment lines.

   `M-^' or `C-c C-d' runs the command `fortran-join-line', which joins
a continuation line back to the previous line, roughly as the inverse
of `fortran-split-line'.  The point must be on a continuation line when
this command is invoked.

   `M-q' in Fortran mode fills the comment block or statement that
point is in.  This removes any excess statement continuations.


File: emacs,  Node: ForIndent Cont,  Next: ForIndent Num,  Prev: ForIndent Commands,  Up: Fortran Indent

30.14.2.2 Continuation Lines
............................

Most Fortran 77 compilers allow two ways of writing continuation lines.
If the first non-space character on a line is in column 5, then that
line is a continuation of the previous line.  We call this "fixed
form".  (In GNU Emacs we always count columns from 0; but note that the
Fortran standard counts from 1.)  The variable
`fortran-continuation-string' specifies what character to put in column
5.  A line that starts with a tab character followed by any digit
except `0' is also a continuation line.  We call this style of
continuation "tab format".  (Fortran 90 introduced "free form," with
another style of continuation lines).

   Fortran mode can use either style of continuation line.  When you
enter Fortran mode, it tries to deduce the proper continuation style
automatically from the buffer contents.  It does this by scanning up to
`fortran-analyze-depth' (default 100) lines from the start of the
buffer.  The first line that begins with either a tab character or six
spaces determines the choice.  If the scan fails (for example, if the
buffer is new and therefore empty), the value of
`fortran-tab-mode-default' (`nil' for fixed form, and non-`nil' for tab
format) is used.  `/t' (`fortran-tab-mode-string') in the mode line
indicates tab format is selected.  Fortran mode sets the value of
`indent-tabs-mode' accordingly.

   If the text on a line starts with the Fortran continuation marker
`$', or if it begins with any non-whitespace character in column 5,
Fortran mode treats it as a continuation line.  When you indent a
continuation line with <TAB>, it converts the line to the current
continuation style.  When you split a Fortran statement with `C-M-j',
the continuation marker on the newline is created according to the
continuation style.

   The setting of continuation style affects several other aspects of
editing in Fortran mode.  In fixed form mode, the minimum column number
for the body of a statement is 6.  Lines inside of Fortran blocks that
are indented to larger column numbers always use only the space
character for whitespace.  In tab format mode, the minimum column
number for the statement body is 8, and the whitespace before column 8
must always consist of one tab character.


File: emacs,  Node: ForIndent Num,  Next: ForIndent Conv,  Prev: ForIndent Cont,  Up: Fortran Indent

30.14.2.3 Line Numbers
......................

If a number is the first non-whitespace in the line, Fortran
indentation assumes it is a line number and moves it to columns 0
through 4.  (Columns always count from 0 in GNU Emacs.)

   Line numbers of four digits or less are normally indented one space.
The variable `fortran-line-number-indent' controls this; it specifies
the maximum indentation a line number can have.  The default value of
the variable is 1.  Fortran mode tries to prevent line number digits
passing column 4, reducing the indentation below the specified maximum
if necessary.  If `fortran-line-number-indent' has the value 5, line
numbers are right-justified to end in column 4.

   Simply inserting a line number is enough to indent it according to
these rules.  As each digit is inserted, the indentation is recomputed.
To turn off this feature, set the variable
`fortran-electric-line-number' to `nil'.


File: emacs,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

30.14.2.4 Syntactic Conventions
...............................

Fortran mode assumes that you follow certain conventions that simplify
the task of understanding a Fortran program well enough to indent it
properly:

   * Two nested `do' loops never share a `continue' statement.

   * Fortran keywords such as `if', `else', `then', `do' and others are
     written without embedded whitespace or line breaks.

     Fortran compilers generally ignore whitespace outside of string
     constants, but Fortran mode does not recognize these keywords if
     they are not contiguous.  Constructs such as `else if' or `end do'
     are acceptable, but the second word should be on the same line as
     the first and not on a continuation line.

If you fail to follow these conventions, the indentation commands may
indent some lines unaesthetically.  However, a correct Fortran program
retains its meaning when reindented even if the conventions are not
followed.


File: emacs,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

30.14.2.5 Variables for Fortran Indentation
...........................................

Several additional variables control how Fortran indentation works:

`fortran-do-indent'
     Extra indentation within each level of `do' statement (default 3).

`fortran-if-indent'
     Extra indentation within each level of `if', `select case', or
     `where' statements (default 3).

`fortran-structure-indent'
     Extra indentation within each level of `structure', `union',
     `map', or `interface' statements (default 3).

`fortran-continuation-indent'
     Extra indentation for bodies of continuation lines (default 5).

`fortran-check-all-num-for-matching-do'
     In Fortran 77, a numbered `do' statement is ended by any statement
     with a matching line number.  It is common (but not compulsory) to
     use a `continue' statement for this purpose.  If this variable has
     a non-`nil' value, indenting any numbered statement must check for
     a `do' that ends there.  If you always end `do' statements with a
     `continue' line (or if you use the more modern `enddo'), then you
     can speed up indentation by setting this variable to `nil'.  The
     default is `nil'.

`fortran-blink-matching-if'
     If this is `t', indenting an `endif' (or `enddo' statement moves
     the cursor momentarily to the matching `if' (or `do') statement to
     show where it is.  The default is `nil'.

`fortran-minimum-statement-indent-fixed'
     Minimum indentation for Fortran statements when using fixed form
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 6.

`fortran-minimum-statement-indent-tab'
     Minimum indentation for Fortran statements for tab format
     continuation line style.  Statement bodies are never indented less
     than this much.  The default is 8.

   The variables controlling the indentation of comments are described
in the following section.


File: emacs,  Node: Fortran Comments,  Next: Fortran Autofill,  Prev: Fortran Indent,  Up: Fortran

30.14.3 Fortran Comments
------------------------

The usual Emacs comment commands assume that a comment can follow a
line of code.  In Fortran 77, the standard comment syntax requires an
entire line to be just a comment.  Therefore, Fortran mode replaces the
standard Emacs comment commands and defines some new variables.

   Fortran mode can also handle the Fortran 90 comment syntax where
comments start with `!' and can follow other text.  Because only some
Fortran 77 compilers accept this syntax, Fortran mode will not insert
such comments unless you have said in advance to do so.  To do this,
set the variable `fortran-comment-line-start' to `"!"'.  If you use an
unusual value, you may also need to adjust
`fortran-comment-line-start-skip'.

`M-;'
     Align comment or insert new comment (`comment-dwim').

`C-x ;'
     Applies to nonstandard `!' comments only.

`C-c ;'
     Turn all lines of the region into comments, or (with argument)
     turn them back into real code (`fortran-comment-region').

   `M-;' in Fortran mode runs the standard `comment-dwim'.  This
recognizes any kind of existing comment and aligns its text
appropriately; if there is no existing comment, a comment is inserted
and aligned.  Inserting and aligning comments are not the same in
Fortran mode as in other modes.

   When a new comment must be inserted, if the current line is blank, a
full-line comment is inserted.  On a non-blank line, a nonstandard `!'
comment is inserted if you have said you want to use them.  Otherwise a
full-line comment is inserted on a new line before the current line.

   Nonstandard `!' comments are aligned like comments in other
languages, but full-line comments are different.  In a standard
full-line comment, the comment delimiter itself must always appear in
column zero.  What can be aligned is the text within the comment.  You
can choose from three styles of alignment by setting the variable
`fortran-comment-indent-style' to one of these values:

`fixed'
     Align the text at a fixed column, which is the sum of
     `fortran-comment-line-extra-indent' and the minimum statement
     indentation.  This is the default.

     The minimum statement indentation is
     `fortran-minimum-statement-indent-fixed' for fixed form
     continuation line style and `fortran-minimum-statement-indent-tab'
     for tab format style.

`relative'
     Align the text as if it were a line of code, but with an additional
     `fortran-comment-line-extra-indent' columns of indentation.

`nil'
     Don't move text in full-line comments automatically.

   In addition, you can specify the character to be used to indent
within full-line comments by setting the variable
`fortran-comment-indent-char' to the single-character string you want
to use.

   Compiler directive lines, or preprocessor lines, have much the same
appearance as comment lines.  It is important, though, that such lines
never be indented at all, no matter what the value of
`fortran-comment-indent-style'.  The variable `fortran-directive-re' is
a regular expression that specifies which lines are directives.
Matching lines are never indented, and receive distinctive font-locking.

   The normal Emacs comment command `C-x ;' has not been redefined.  If
you use `!' comments, this command can be used with them.  Otherwise it
is useless in Fortran mode.

   The command `C-c ;' (`fortran-comment-region') turns all the lines
of the region into comments by inserting the string `C$$$' at the front
of each one.  With a numeric argument, it turns the region back into
live code by deleting `C$$$' from the front of each line in it.  The
string used for these comments can be controlled by setting the
variable `fortran-comment-region'.  Note that here we have an example
of a command and a variable with the same name; these two uses of the
name never conflict because in Lisp and in Emacs it is always clear
from the context which one is meant.


File: emacs,  Node: Fortran Autofill,  Next: Fortran Columns,  Prev: Fortran Comments,  Up: Fortran

30.14.4 Auto Fill in Fortran Mode
---------------------------------

Fortran mode has specialized support for Auto Fill mode, which is a
minor mode that automatically splits statements as you insert them when
they become too wide.  Splitting a statement involves making
continuation lines using `fortran-continuation-string' (*note ForIndent
Cont::).  This splitting happens when you type <SPC>, <RET>, or <TAB>,
and also in the Fortran indentation commands.  You activate Auto Fill
in Fortran mode in the normal way.  *Note Auto Fill::.

   Auto Fill breaks lines at spaces or delimiters when the lines get
longer than the desired width (the value of `fill-column').  The
delimiters (besides whitespace) that Auto Fill can break at are `+',
`-', `/', `*', `=', `<', `>', and `,'.  The line break comes after the
delimiter if the variable `fortran-break-before-delimiters' is `nil'.
Otherwise (and by default), the break comes before the delimiter.

   To enable Auto Fill in all Fortran buffers, add `turn-on-auto-fill'
to `fortran-mode-hook'.  *Note Hooks::.


File: emacs,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Autofill,  Up: Fortran

30.14.5 Checking Columns in Fortran
-----------------------------------

In standard Fortran 77, anything beyond column 72 is ignored.  Most
compilers provide an option to change this (for example,
`-ffixed-line-length-N' in gfortran).  Customize the variable
`fortran-line-length' to change the line length in Fortran mode.
Anything beyond this point is font-locked as a comment.  (Unless it is
inside a string: strings that extend beyond `fortran-line-length' will
confuse font-lock.)

`C-c C-r'
     Display a "column ruler" momentarily above the current line
     (`fortran-column-ruler').

`C-c C-w'
     Split the current window horizontally temporarily so that it is
     `fortran-line-length' columns wide
     (`fortran-window-create-momentarily').  This may help you avoid
     making lines longer than the character limit imposed by your
     Fortran compiler.

`C-u C-c C-w'
     Split the current window horizontally so that it is
     `fortran-line-length' columns wide (`fortran-window-create').  You
     can then continue editing.

`M-x fortran-strip-sequence-nos'
     Delete all text in column `fortran-line-length' and beyond.

   The command `C-c C-r' (`fortran-column-ruler') shows a column ruler
momentarily above the current line.  The comment ruler is two lines of
text that show you the locations of columns with special significance in
Fortran programs.  Square brackets show the limits of the columns for
line numbers, and curly brackets show the limits of the columns for the
statement body.  Column numbers appear above them.

   Note that the column numbers count from zero, as always in GNU Emacs.
As a result, the numbers may be one less than those you are familiar
with; but the positions they indicate in the line are standard for
Fortran.

   The text used to display the column ruler depends on the value of the
variable `indent-tabs-mode'.  If `indent-tabs-mode' is `nil', then the
value of the variable `fortran-column-ruler-fixed' is used as the
column ruler.  Otherwise, the value of the variable
`fortran-column-ruler-tab' is displayed.  By changing these variables,
you can change the column ruler display.

   `C-c C-w' (`fortran-window-create-momentarily') temporarily splits
the current window horizontally, making a window `fortran-line-length'
columns wide, so you can see any lines that are too long.  Type a space
to restore the normal width.

   You can also split the window horizontally and continue editing with
the split in place.  To do this, use `C-u C-c C-w' (`M-x
fortran-window-create').  By editing in this window you can immediately
see when you make a line too wide to be correct Fortran.

   The command `M-x fortran-strip-sequence-nos' deletes all text in
column `fortran-line-length' and beyond, on all lines in the current
buffer.  This is the easiest way to get rid of old sequence numbers.


File: emacs,  Node: Fortran Abbrev,  Prev: Fortran Columns,  Up: Fortran

30.14.6 Fortran Keyword Abbrevs
-------------------------------

Fortran mode provides many built-in abbrevs for common keywords and
declarations.  These are the same sort of abbrev that you can define
yourself.  To use them, you must turn on Abbrev mode.  *Note Abbrevs::.

   The built-in abbrevs are unusual in one way: they all start with a
semicolon.  For example, one built-in Fortran abbrev is `;c' for
`continue'.  If you insert `;c' and then insert a punctuation character
such as a space or a newline, the `;c' expands automatically to
`continue', provided Abbrev mode is enabled.

   Type `;?' or `;C-h' to display a list of all the built-in Fortran
abbrevs and what they stand for.


File: emacs,  Node: Building,  Next: Maintaining,  Prev: Programs,  Up: Top

31 Compiling and Testing Programs
*********************************

The previous chapter discusses the Emacs commands that are useful for
making changes in programs.  This chapter deals with commands that
assist in the larger process of compiling and testing programs.

* Menu:

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Grep Searching::      Searching with grep.
* Flymake::             Finding syntax errors on the fly.
* Debuggers::	        Running symbolic debuggers for non-Lisp programs.
* Executing Lisp::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* External Lisp::         Communicating through Emacs with a separate Lisp.


File: emacs,  Node: Compilation,  Next: Compilation Mode,  Up: Building

31.1 Running Compilations under Emacs
=====================================

Emacs can run compilers for noninteractive languages such as C and
Fortran as inferior processes, feeding the error log into an Emacs
buffer.  It can also parse the error messages and show you the source
lines where compilation errors occurred.

`M-x compile'
     Run a compiler asynchronously under Emacs, with error messages
     going to the `*compilation*' buffer.

`M-x recompile'
     Invoke a compiler with the same command as in the last invocation
     of `M-x compile'.

`M-x kill-compilation'
     Kill the running compilation subprocess.

   To run `make' or another compilation command, do `M-x compile'.
This command reads a shell command line using the minibuffer, and then
executes the command in an inferior shell, putting output in the buffer
named `*compilation*'.  The current buffer's default directory is used
as the working directory for the execution of the command; normally,
therefore, the compilation happens in this directory.

   The default for the compilation command is normally `make -k', which
is correct most of the time for nontrivial programs.  *Note Make:
(make)Top.  If you have done `M-x compile' before, the default each
time is the command you used the previous time.  `compile' stores this
command in the variable `compile-command', so setting that variable
specifies the default for the next use of `M-x compile'.  If a file
specifies a file local value for `compile-command', that provides the
default when you type `M-x compile' in that file's buffer.  *Note File
Variables::.

   Starting a compilation displays the buffer `*compilation*' in
another window but does not select it.  The buffer's mode line tells
you whether compilation is finished, with the word `run', `signal' or
`exit' inside the parentheses.  You do not have to keep this buffer
visible; compilation continues in any case.  While a compilation is
going on, the string `Compiling' appears in the mode lines of all
windows.  When this string disappears, the compilation is finished.

   If you want to watch the compilation transcript as it appears, switch
to the `*compilation*' buffer and move point to the end of the buffer.
When point is at the end, new compilation output is inserted above
point, which remains at the end.  If point is not at the end of the
buffer, it remains fixed while more compilation output is added at the
end of the buffer.

   If you change the variable `compilation-scroll-output' to a
non-`nil' value, the compilation buffer will scroll automatically to
follow the output as it comes in.  If the value is `first-error', the
scrolling stops at the first error that appears, leaving point at that
error.  For any other non-`nil' value, the buffer continues scrolling
until there is no more output.

   To rerun the last compilation with the same command, type `M-x
recompile'.  This automatically reuses the compilation command from the
last invocation of `M-x compile'.  It also reuses the `*compilation*'
buffer and starts the compilation in its default directory, which is
the directory in which the previous compilation was started.

   When the compiler process terminates, for whatever reason, the mode
line of the `*compilation*' buffer changes to say `exit' (followed by
the exit code, `[0]' for a normal exit), or `signal' (if a signal
terminated the process), instead of `run'.

   Starting a new compilation also kills any compilation already
running in `*compilation*', as the buffer can only handle one
compilation at any time.  However, `M-x compile' asks for confirmation
before actually killing a compilation that is running.  You can also
kill the compilation process with `M-x kill-compilation'.

   If you want to run two compilations at once, you should start the
first one, then rename the `*compilation*' buffer (perhaps using
`rename-uniquely'; *note Misc Buffer::), and start the other
compilation.  That will create a new `*compilation*' buffer.

   Emacs does not expect a compiler process to launch asynchronous
subprocesses; if it does, and they keep running after the main compiler
process has terminated, Emacs may kill them or their output may not
arrive in Emacs.  To avoid this problem, make the main process wait for
its subprocesses to finish.  In a shell script, you can do this using
`$!' and `wait', like this:

     (sleep 10; echo 2nd)& pid=$!  # Record pid of subprocess
     echo first message
     wait $pid                     # Wait for subprocess

   If the background process does not output to the compilation buffer,
so you only need to prevent it from being killed when the main
compilation process terminates, this is sufficient:

     nohup COMMAND; sleep 1

   You can control the environment passed to the compilation command
with the variable `compilation-environment'.  Its value is a list of
environment variable settings; each element should be a string of the
form `"ENVVARNAME=VALUE"'.  These environment variable settings
override the usual ones.


File: emacs,  Node: Compilation Mode,  Next: Compilation Shell,  Prev: Compilation,  Up: Building

31.2 Compilation Mode
=====================

The `*compilation*' buffer uses a special major mode, Compilation mode,
whose main feature is to provide a convenient way to visit the source
line corresponding to an error message.  These commands are also
available in other special buffers that list locations in files,
including those made by `M-x grep' and `M-x occur'.

`M-g M-n'
`M-g n'
`C-x `'
     Visit the locus of the next error message or match.

`M-g M-p'
`M-g p'
     Visit the locus of the previous error message or match.

`<RET>'
     Visit the locus of the error message that point is on.  This
     command is used in the compilation buffer.

`Mouse-2'
     Visit the locus of the error message that you click on.

`M-n'
     Find and highlight the locus of the next error message, without
     selecting the source buffer.

`M-p'
     Find and highlight the locus of the previous error message, without
     selecting the source buffer.

`M-}'
     Move point to the next error for a different file than the current
     one.

`M-{'
     Move point to the previous error for a different file than the
     current one.

`C-c C-f'
     Toggle Next Error Follow minor mode, which makes cursor motion in
     the compilation buffer produce automatic source display.

   You can visit the source for any particular error message by moving
point in the `*compilation*' buffer to that error message and typing
<RET> (`compile-goto-error').  Alternatively, you can click `Mouse-2'
on the error message; you need not switch to the `*compilation*' buffer
first.  If you set the variable `compilation-auto-jump-to-first-error'
to a non-`nil' value, Emacs automatically jumps to the first error, if
any, as soon as it appears in the `*compilation*' buffer.

   To parse the compiler error messages sequentially, type `C-x `'
(`next-error').  The character following the `C-x' is the backquote or
"grave accent," not the single-quote.  This command is available in all
buffers, not just in `*compilation*'; it displays the next error
message at the top of one window and source location of the error in
another window.  It also temporarily highlights the relevant source
line, for a period controlled by the variable `next-error-highlight'.

   The first time `C-x `' is used after the start of a compilation, it
moves to the first error's location.  Subsequent uses of `C-x `'
advance down to subsequent errors.  If you visit a specific error
message with <RET> or `Mouse-2', subsequent `C-x `' commands advance
from there.  When `C-x `' gets to the end of the buffer and finds no
more error messages to visit, it fails and signals an Emacs error.
`C-u C-x `' starts scanning from the beginning of the compilation
buffer, and goes to the first error's location.

   By default, `C-x `' skips less important messages.  The variable
`compilation-skip-threshold' controls this.  If its value is 2, `C-x `'
skips anything less than error, 1 skips anything less than warning, and
0 doesn't skip any messages.  The default is 1.

   When the window has a left fringe, an arrow in the fringe points to
the current message in the compilation buffer. The variable
`compilation-context-lines' controls the number of lines of leading
context to display before the current message.  Going to an error
message location scrolls the `*compilation*' buffer to put the message
that far down from the top.  The value `nil' is special: if there's a
left fringe, the window doesn't scroll at all if the message is already
visible.  If there is no left fringe, `nil' means display the message
at the top of the window.

   If you're not in the compilation buffer when you run `next-error',
Emacs will look for a buffer that contains error messages.  First, it
looks for one displayed in the selected frame, then for one that
previously had `next-error' called on it, and then at the current
buffer.  Finally, Emacs looks at all the remaining buffers.
`next-error' signals an error if it can't find any such buffer.

   To parse messages from the compiler, Compilation mode uses the
variable `compilation-error-regexp-alist' which lists various formats
of error messages and tells Emacs how to extract the source file and
the line number from the text of a message.  If your compiler isn't
supported, you can tailor Compilation mode to it by adding elements to
that list.  A similar variable `grep-regexp-alist' tells Emacs how to
parse output of a `grep' command.

   Compilation mode also redefines the keys <SPC> and <DEL> to scroll
by screenfuls, and `M-n' (`compilation-next-error') and `M-p'
(`compilation-previous-error') to move to the next or previous error
message.  You can also use `M-{' (`compilation-next-file' and `M-}'
(`compilation-previous-file') to move up or down to an error message
for a different source file.

   You can type `C-c C-f' to toggle Next Error Follow mode.  In this
minor mode, ordinary cursor motion in the compilation buffer
automatically updates the source buffer.  For instance, moving the
cursor to the next error message causes the location of that error to
be displayed immediately.

   The features of Compilation mode are also available in a minor mode
called Compilation Minor mode.  This lets you parse error messages in
any buffer, not just a normal compilation output buffer.  Type `M-x
compilation-minor-mode' to enable the minor mode.  This defines the keys
<RET> and `Mouse-2', as in the Compilation major mode.

   Compilation minor mode works in any buffer, as long as the contents
are in a format that it understands.  In an Rlogin buffer (*note Remote
Host::), Compilation minor mode automatically accesses remote source
files by FTP (*note File Names::).


File: emacs,  Node: Compilation Shell,  Next: Grep Searching,  Prev: Compilation Mode,  Up: Building

31.3 Subshells for Compilation
==============================

Emacs uses a shell to run the compilation command, but specifies the
option for a noninteractive shell.  This means, in particular, that the
shell should start with no prompt.  If you find your usual shell prompt
making an unsightly appearance in the `*compilation*' buffer, it means
you have made a mistake in your shell's init file by setting the prompt
unconditionally.  (This init file's name may be `.bashrc', `.profile',
`.cshrc', `.shrc', or various other things, depending on the shell you
use.)  The shell init file should set the prompt only if there already
is a prompt.  Here's how to do it in bash:

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

And here's how to do it in csh:

     if ($?prompt) set prompt = ...

   There may well be other things that your shell's init file ought to
do only for an interactive shell.  You can use the same method to
conditionalize them.

   The MS-DOS "operating system" does not support asynchronous
subprocesses; to work around this lack, `M-x compile' runs the
compilation command synchronously on MS-DOS.  As a consequence, you must
wait until the command finishes before you can do anything else in
Emacs.  *Note MS-DOS::.


File: emacs,  Node: Grep Searching,  Next: Flymake,  Prev: Compilation Shell,  Up: Building

31.4 Searching with Grep under Emacs
====================================

Just as you can run a compiler from Emacs and then visit the lines with
compilation errors, you can also run `grep' and then visit the lines on
which matches were found.  This works by treating the matches reported
by `grep' as if they were "errors."  The buffer of matches uses Grep
mode, which is a variant of Compilation mode (*note Compilation Mode::).

`M-x grep'
`M-x lgrep'
     Run `grep' asynchronously under Emacs, with matching lines listed
     in the buffer named `*grep*'.

`M-x grep-find'
`M-x find-grep'
`M-x rgrep'
     Run `grep' via `find', and collect output in the buffer named
     `*grep*'.

`M-x zrgrep'
     Run `zgrep' and collect output in the buffer named `*grep*'.

`M-x kill-grep'
     Kill the running `grep' subprocess.

   To run `grep', type `M-x grep', then enter a command line that
specifies how to run `grep'.  Use the same arguments you would give
`grep' when running it normally: a `grep'-style regexp (usually in
single-quotes to quote the shell's special characters) followed by file
names, which may use wildcards.  If you specify a prefix argument for
`M-x grep', it finds the tag (*note Tags::) in the buffer around point,
and puts that into the default `grep' command.

   Your command need not simply run `grep'; you can use any shell
command that produces output in the same format.  For instance, you can
chain `grep' commands, like this:

     grep -nH -e foo *.el | grep bar | grep toto

   The output from `grep' goes in the `*grep*' buffer.  You can find
the corresponding lines in the original files using `C-x `', <RET>, and
so forth, just like compilation errors.

   Some grep programs accept a `--color' option to output special
markers around matches for the purpose of highlighting.  You can make
use of this feature by setting `grep-highlight-matches' to `t'.  When
displaying a match in the source buffer, the exact match will be
highlighted, instead of the entire source line.

   The command `M-x grep-find' (also available as `M-x find-grep') is
similar to `M-x grep', but it supplies a different initial default for
the command--one that runs both `find' and `grep', so as to search
every file in a directory tree.  See also the `find-grep-dired'
command, in *note Dired and Find::.

   The commands `M-x lgrep' (local grep) and `M-x rgrep' (recursive
grep) are more user-friendly versions of `grep' and `grep-find', which
prompt separately for the regular expression to match, the files to
search, and the base directory for the search.  Case sensitivity of the
search is controlled by the current value of `case-fold-search'.  The
command `M-x zrgrep' is similar to `rgrep', but it calls `zgrep'
instead of `grep' to search the contents of gzipped files.

   These commands build the shell commands based on the variables
`grep-template' (for `lgrep') and `grep-find-template' (for `rgrep').
The files to search can use aliases defined in the variable
`grep-files-aliases'.

   Subdirectories listed in the variable
`grep-find-ignored-directories' such as those typically used by various
version control systems, like CVS and arch, are automatically skipped
by `rgrep'.


File: emacs,  Node: Flymake,  Next: Debuggers,  Prev: Grep Searching,  Up: Building

31.5 Finding Syntax Errors On The Fly
=====================================

Flymake mode is a minor mode that performs on-the-fly syntax checking
for many programming and markup languages, including C, C++, Perl,
HTML, and TeX/LaTeX.  It is somewhat analogous to Flyspell mode, which
performs spell checking for ordinary human languages in a similar
fashion (*note Spelling::).  As you edit a file, Flymake mode runs an
appropriate syntax checking tool in the background, using a temporary
copy of the buffer.  It then parses the error and warning messages, and
highlights the erroneous lines in the buffer.  The syntax checking tool
used depends on the language; for example, for C/C++ files this is
usually the C compiler.  Flymake can also use build tools such as
`make' for checking complicated projects.

   To activate Flymake mode, type `M-x flymake-mode'.  You can move to
the errors spotted by Flymake mode with `M-x flymake-goto-next-error'
and `M-x flymake-goto-prev-error'.  To display any error messages
associated with the current line, use `M-x
flymake-display-err-menu-for-current-line'.

   For more details about using Flymake, see *note Flymake:
(flymake)Top.


File: emacs,  Node: Debuggers,  Next: Executing Lisp,  Prev: Flymake,  Up: Building

31.6 Running Debuggers Under Emacs
==================================

The GUD (Grand Unified Debugger) library provides an Emacs interface to
a wide variety of symbolic debuggers.  Unlike the GDB graphical
interface, which only runs GDB (*note GDB Graphical Interface::), GUD
can also run DBX, SDB, XDB, Perl's debugging mode, the Python debugger
PDB, or the Java Debugger JDB.

   In addition, Emacs contains a built-in system for debugging Emacs
Lisp programs.  *Note The Lisp Debugger: (elisp)Debugging, for
information on the Emacs Lisp debugger.

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.
* GDB Graphical Interface::  An enhanced mode that uses GDB features to
                        implement a graphical debugging environment through
                        Emacs.


File: emacs,  Node: Starting GUD,  Next: Debugger Operation,  Up: Debuggers

31.6.1 Starting GUD
-------------------

There are several commands for starting a debugger under GUD, each
corresponding to a particular debugger program.

`M-x gdb <RET> FILE <RET>'
     Run GDB as a subprocess of Emacs.  This uses an IDE-like graphical
     interface; see *note GDB Graphical Interface::.  Only GDB works
     with the graphical interface.

`M-x gud-gdb <RET> FILE <RET>'
     Run GDB as a subprocess of Emacs.  This command creates a buffer
     for input and output to GDB, and switches to it.  If a GDB buffer
     already exists, it just switches to that buffer.

`M-x dbx <RET> FILE <RET>'
     Run DBX as a subprocess of Emacs.  Since Emacs does not implement a
     graphical interface for DBX, communication with DBX works by typing
     commands in the GUD interaction buffer.  The same is true for all
     the other supported debuggers.

`M-x xdb <RET> FILE <RET>'
     Run XDB as a subprocess of Emacs.  Use the variable
     `gud-xdb-directories' to specify directories to search for source
     files.

`M-x sdb <RET> FILE <RET>'
     Run SDB as a subprocess of Emacs.

     Some versions of SDB do not mention source file names in their
     messages.  When you use them, you need to have a valid tags table
     (*note Tags::) in order for GUD to find functions in the source
     code.  If you have not visited a tags table or the tags table
     doesn't list one of the functions, you get a message saying `The
     sdb support requires a valid tags table to work'.  If this
     happens, generate a valid tags table in the working directory and
     try again.

`M-x perldb <RET> FILE <RET>'
     Run the Perl interpreter in debug mode to debug FILE, a Perl
     program.

`M-x jdb <RET> FILE <RET>'
     Run the Java debugger to debug FILE.

`M-x pdb <RET> FILE <RET>'
     Run the Python debugger to debug FILE.

   Each of these commands takes one argument: a command line to invoke
the debugger.  In the simplest case, specify just the name of the
executable file you want to debug.  You may also use options that the
debugger supports.  However, shell wildcards and variables are not
allowed.  GUD assumes that the first argument not starting with a `-'
is the executable file name.

   Tramp provides a facility to debug programs on remote hosts (*note
Running a debugger on a remote host: (tramp)Running a debugger on a
remote host.), whereby both the debugger and the program being debugged
are on the same remote host.  This should not be confused with
debugging programs remotely, where the program and the debugger run on
different machines, as can be done using the GDB remote debugging
feature, for example (*note Debugging Remote Programs: (gdb)Remote
Debugging.).


File: emacs,  Node: Debugger Operation,  Next: Commands of GUD,  Prev: Starting GUD,  Up: Debuggers

31.6.2 Debugger Operation
-------------------------

Generally when you run a debugger with GUD, the debugger uses an Emacs
buffer for its ordinary input and output.  This is called the GUD
buffer.  Input and output from the program you are debugging also use
this buffer.  We call this "text command mode".  The GDB Graphical
Interface can use further buffers (*note GDB Graphical Interface::).

   The debugger displays the source files of the program by visiting
them in Emacs buffers.  An arrow in the left fringe indicates the
current execution line.(1)  Moving point in this buffer does not move
the arrow.  The arrow is not part of the file's text; it appears only
on the screen.

   You can start editing these source files at any time in the buffers
that display them.  If you do modify a source file, keep in mind that
inserting or deleting lines will throw off the arrow's positioning; GUD
has no way of figuring out which line corresponded before your changes
to the line number in a debugger message.  Also, you'll typically have
to recompile and restart the program for your changes to be reflected
in the debugger's tables.

   The Tooltip facility (*note Tooltips::) provides support for GUD.
You activate this feature by turning on the minor mode
`gud-tooltip-mode'.  Then you can display a variable's value in a
tooltip simply by pointing at it with the mouse.  This operates in the
GUD buffer and in source buffers with major modes in the list
`gud-tooltip-modes'.  If the variable `gud-tooltip-echo-area' is
non-`nil' then the variable's value is displayed in the echo area.
When debugging a C program using the GDB Graphical Interface, you can
also display macro definitions associated with an identifier when the
program is not executing.

   GUD tooltips are disabled when you use GDB in text command mode
(*note GDB Graphical Interface::), because displaying an expression's
value in GDB can sometimes expand a macro and result in a side effect
that interferes with the program's operation.  The GDB graphical
interface supports GUD tooltips and assures they will not cause side
effects.

   ---------- Footnotes ----------

   (1) On a text-only terminal, the arrow appears as `=>' and overlays
the first two text columns.


File: emacs,  Node: Commands of GUD,  Next: GUD Customization,  Prev: Debugger Operation,  Up: Debuggers

31.6.3 Commands of GUD
----------------------

The GUD interaction buffer uses a variant of Shell mode, so the Emacs
commands of Shell mode are available (*note Shell Mode::).  All the
usual commands for your debugger are available, and you can use the
Shell mode history commands to repeat them.  If you wish, you can
control your debugger process entirely through this buffer.

   GUD mode also provides commands for setting and clearing
breakpoints, for selecting stack frames, and for stepping through the
program.  These commands are available both in the GUD buffer and
globally, but with different key bindings.  It also has its own tool
bar from which you can invoke the more common commands by clicking on
the appropriate icon.  This is particularly useful for repetitive
commands like `gud-next' and `gud-step', and allows you to keep the GUD
buffer hidden.

   The breakpoint commands are normally used in source file buffers,
because that is the easiest way to specify where to set or clear the
breakpoint.  Here's the global command to set a breakpoint:

`C-x <SPC>'
     Set a breakpoint on the source line that point is on.

   Here are the other special commands provided by GUD.  The keys
starting with `C-c' are available only in the GUD interaction buffer.
The key bindings that start with `C-x C-a' are available in the GUD
interaction buffer and also in source files.  Some of these commands
are not available to all the supported debuggers.

`C-c C-l'
`C-x C-a C-l'
     Display in another window the last line referred to in the GUD
     buffer (that is, the line indicated in the last location message).
     This runs the command `gud-refresh'.

`C-c C-s'
`C-x C-a C-s'
     Execute a single line of code (`gud-step').  If the line contains
     a function call, execution stops after entering the called
     function.

`C-c C-n'
`C-x C-a C-n'
     Execute a single line of code, stepping across entire function
     calls at full speed (`gud-next').

`C-c C-i'
`C-x C-a C-i'
     Execute a single machine instruction (`gud-stepi').

`C-c C-p'
`C-x C-a C-p'
     Evaluate the expression at point (`gud-print').  If Emacs does not
     print the exact expression that you want, mark it as a region
     first.

`C-c C-r'
`C-x C-a C-r'
     Continue execution without specifying any stopping point.  The
     program will run until it hits a breakpoint, terminates, or gets a
     signal that the debugger is checking for (`gud-cont').

`C-c C-d'
`C-x C-a C-d'
     Delete the breakpoint(s) on the current source line, if any
     (`gud-remove').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

`C-c C-t'
`C-x C-a C-t'
     Set a temporary breakpoint on the current source line, if any
     (`gud-tbreak').  If you use this command in the GUD interaction
     buffer, it applies to the line where the program last stopped.

`C-c <'
`C-x C-a <'
     Select the next enclosing stack frame (`gud-up').  This is
     equivalent to the GDB command `up'.

`C-c >'
`C-x C-a >'
     Select the next inner stack frame (`gud-down').  This is
     equivalent to the GDB command `down'.

`C-c C-u'
`C-x C-a C-u'
     Continue execution to the current line (`gud-until').  The program
     will run until it hits a breakpoint, terminates, gets a signal
     that the debugger is checking for, or reaches the line on which the
     cursor currently sits.

`C-c C-f'
`C-x C-a C-f'
     Run the program until the selected stack frame returns or stops
     for some other reason (`gud-finish').

   If you are using GDB, these additional key bindings are available:

`C-x C-a C-j'
     Only useful in a source buffer, `gud-jump' transfers the program's
     execution point to the current line.  In other words, the next
     line that the program executes will be the one where you gave the
     command.  If the new execution line is in a different function from
     the previously one, GDB prompts for confirmation since the results
     may be bizarre.  See the GDB manual entry regarding `jump' for
     details.

`<TAB>'
     With GDB, complete a symbol name (`gud-gdb-complete-command').
     This key is available only in the GUD interaction buffer.

   These commands interpret a numeric argument as a repeat count, when
that makes sense.

   Because <TAB> serves as a completion command, you can't use it to
enter a tab as input to the program you are debugging with GDB.
Instead, type `C-q <TAB>' to enter a tab.


File: emacs,  Node: GUD Customization,  Next: GDB Graphical Interface,  Prev: Commands of GUD,  Up: Debuggers

31.6.4 GUD Customization
------------------------

On startup, GUD runs one of the following hooks: `gdb-mode-hook', if
you are using GDB; `dbx-mode-hook', if you are using DBX;
`sdb-mode-hook', if you are using SDB; `xdb-mode-hook', if you are
using XDB; `perldb-mode-hook', for Perl debugging mode;
`pdb-mode-hook', for PDB; `jdb-mode-hook', for JDB.  You can use these
hooks to define custom key bindings for the debugger interaction
buffer.  *Note Hooks::.

   Here is a convenient way to define a command that sends a particular
command string to the debugger, and set up a key binding for it in the
debugger interaction buffer:

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

   This defines a command named FUNCTION which sends CMDSTRING to the
debugger process, and gives it the documentation string DOCSTRING.  You
can then use the command FUNCTION in any buffer.  If BINDING is
non-`nil', `gud-def' also binds the command to `C-c BINDING' in the GUD
buffer's mode and to `C-x C-a BINDING' generally.

   The command string CMDSTRING may contain certain `%'-sequences that
stand for data to be filled in at the time FUNCTION is called:

`%f'
     The name of the current source file.  If the current buffer is the
     GUD buffer, then the "current source file" is the file that the
     program stopped in.

`%l'
     The number of the current source line.  If the current buffer is
     the GUD buffer, then the "current source line" is the line that
     the program stopped in.

`%e'
     In transient-mark-mode the text in the region, if it is active.
     Otherwise the text of the C lvalue or function-call expression at
     or adjacent to point.

`%a'
     The text of the hexadecimal address at or adjacent to point.

`%p'
     The numeric argument of the called function, as a decimal number.
     If the command is used without a numeric argument, `%p' stands for
     the empty string.

     If you don't use `%p' in the command string, the command you define
     ignores any numeric argument.

`%d'
     The name of the directory of the current source file.

`%c'
     Fully qualified class name derived from the expression surrounding
     point (jdb only).


File: emacs,  Node: GDB Graphical Interface,  Prev: GUD Customization,  Up: Debuggers

31.6.5 GDB Graphical Interface
------------------------------

The command `gdb' starts GDB in a graphical interface, using Emacs
windows for display program state information.  With it, you do not
need to use textual GDB commands; you can control the debugging session
with the mouse.  For example, you can click in the fringe of a source
buffer to set a breakpoint there, or on a stack frame in the stack
buffer to select that frame.

   This mode requires telling GDB that its "screen size" is unlimited,
so it sets the height and width accordingly.  For correct operation you
must not change these values during the GDB session.

   To run GDB in text command mode, like the other debuggers in Emacs,
use `M-x gud-gdb'.  You need to use text command mode to debug multiple
programs within one Emacs session.

* Menu:

* GDB-UI Layout::               Control the number of displayed buffers.
* Source Buffers::              Use the mouse in the fringe/margin to
                                control your program.
* Breakpoints Buffer::          A breakpoint control panel.
* Stack Buffer::                Select a frame from the call stack.
* Other GDB-UI Buffers::        Input/output, locals, registers,
                                assembler, threads and memory buffers.
* Watch Expressions::           Monitor variable values in the speedbar.
* Reverse Debugging::           Execute and reverse debug your program.


File: emacs,  Node: GDB-UI Layout,  Next: Source Buffers,  Up: GDB Graphical Interface

31.6.5.1 GDB User Interface Layout
..................................

If the variable `gdb-many-windows' is `nil' (the default value) then
`M-x gdb' normally displays only the GUD buffer.  However, if the
variable `gdb-show-main' is also non-`nil', it starts with two windows:
one displaying the GUD buffer, and the other showing the source for the
`main' function of the program you are debugging.

   If `gdb-many-windows' is non-`nil', then `M-x gdb' displays the
following frame layout:

     +--------------------------------+--------------------------------+
     |   GUD buffer (I/O of GDB)      |   Locals/Registers buffer      |
     |--------------------------------+--------------------------------+
     |   Primary Source buffer        |   I/O buffer for debugged pgm  |
     |--------------------------------+--------------------------------+
     |   Stack buffer                 |   Breakpoints/Threads buffer   |
     +--------------------------------+--------------------------------+

   However, if `gdb-use-separate-io-buffer' is `nil', the I/O buffer
does not appear and the primary source buffer occupies the full width
of the frame.

   If you change the window layout, for example, while editing and
re-compiling your program, then you can restore this standard window
layout with the command `gdb-restore-windows'.

   To switch between this standard layout and a simple layout
containing just the GUD buffer and a source file, type `M-x
gdb-many-windows'.

   You may also specify additional GDB-related buffers to display,
either in the same frame or a different one.  Select the buffers you
want with the `GUD->GDB-Windows' and `GUD->GDB-Frames' sub-menus.  If
the menu-bar is unavailable, type `M-x gdb-display-BUFFERTYPE-buffer'
or `M-x gdb-frame-BUFFERTYPE-buffer' respectively, where BUFFERTYPE is
the relevant buffer type, such as `breakpoints'.  Most of these buffers
are read-only, and typing `q' in them kills them.

   When you finish debugging, kill the GUD buffer with `C-x k', which
will also kill all the buffers associated with the session.  However
you need not do this if, after editing and re-compiling your source
code within Emacs, you wish continue debugging.  When you restart
execution, GDB will automatically find your new executable.  Keeping
the GUD buffer has the advantage of keeping the shell history as well
as GDB's breakpoints.  You do need to check that the breakpoints in
recently edited source files are still in the right places.


File: emacs,  Node: Source Buffers,  Next: Breakpoints Buffer,  Prev: GDB-UI Layout,  Up: GDB Graphical Interface

31.6.5.2 Source Buffers
.......................

Many GDB commands can be entered using key bindings or the tool bar but
sometimes it is quicker to use the fringe.  These commands either
manipulate breakpoints or control program execution.  When there is no
fringe, you can use the margin but this is only present when the source
file already has a breakpoint.

   You can click `Mouse-1' in the fringe or display margin of a source
buffer to set a breakpoint there and, on a graphical display, a red
bullet will appear on that line.  If a breakpoint already exists on
that line, the same click will remove it.  You can also enable or
disable a breakpoint by clicking `C-Mouse-1' on the bullet.

   A solid arrow in the left fringe of a source buffer indicates the
line of the innermost frame where the debugged program has stopped. A
hollow arrow indicates the current execution line of higher level
frames.

   If you drag the arrow in the fringe with `Mouse-1'
(`gdb-mouse-until'), execution will continue to the line where you
release the button, provided it is still in the same frame.
Alternatively, you can click `Mouse-3' at some point in the fringe of
this buffer and execution will advance to there.  A similar command
(`gdb-mouse-jump') allows you to jump to a source line without
executing the intermediate lines by clicking `C-Mouse-3'.  This command
allows you to go backwards which can be useful for running through code
that has already executed, in order to examine its execution in more
detail.

`Mouse-1'
     Set or clear a breakpoint.

`C-Mouse-1'
     Enable or disable a breakpoint.

`Mouse-3'
     Continue execution to here.

`C-Mouse-3'
     Jump to here.

   If the variable `gdb-find-source-frame' is non-`nil' and execution
stops in a frame for which there is no source code e.g after an
interrupt, then Emacs finds and displays the first frame further up
stack for which there is source.  If it is `nil' then the source buffer
continues to display the last frame which maybe more useful, for
example, when re-setting a breakpoint.


File: emacs,  Node: Breakpoints Buffer,  Next: Stack Buffer,  Prev: Source Buffers,  Up: GDB Graphical Interface

31.6.5.3 Breakpoints Buffer
...........................

The breakpoints buffer shows the existing breakpoints, watchpoints and
catchpoints (*note Breakpoints: (gdb)Breakpoints.).  It has these
special commands, which mostly apply to the "current breakpoint", the
breakpoint which point is on.

`<SPC>'
     Enable/disable the current breakpoint (`gdb-toggle-breakpoint').
     On a graphical display, this changes the color of a bullet in the
     margin of a source buffer at the relevant line.  This is red when
     the breakpoint is enabled and grey when it is disabled.  Text-only
     terminals correspondingly display a `B' or `b'.

`D'
     Delete the current breakpoint (`gdb-delete-breakpoint').

`<RET>'
     Visit the source line for the current breakpoint
     (`gdb-goto-breakpoint').

`Mouse-2'
     Visit the source line for the breakpoint you click on.

   When `gdb-many-windows' is non-`nil', the breakpoints buffer shares
its window with the threads buffer.  To switch from one to the other
click with `Mouse-1' on the relevant button in the header line.


File: emacs,  Node: Stack Buffer,  Next: Other GDB-UI Buffers,  Prev: Breakpoints Buffer,  Up: GDB Graphical Interface

31.6.5.4 Stack Buffer
.....................

The stack buffer displays a "call stack", with one line for each of the
nested subroutine calls ("stack frames") now active in the program.
*Note Backtraces: (gdb)Backtrace.

   An arrow in the fringe points to the selected frame or, if the
fringe is not present, the number of the selected frame is displayed in
reverse contrast.  To select a frame in GDB, move point in the stack
buffer to that stack frame and type <RET> (`gdb-frames-select'), or
click `Mouse-2' on a stack frame.  If the locals buffer is visible,
selecting a stack frame updates it to display the local variables of the
new frame.

