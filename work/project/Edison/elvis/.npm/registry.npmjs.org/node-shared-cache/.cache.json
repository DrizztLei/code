{"_id":"node-shared-cache","_rev":"8-f0b0d51c3b1391b08de89fa9cd4c4be8","name":"node-shared-cache","description":"Interprocess shared memory cache for Node.JS","dist-tags":{"latest":"1.4.0"},"versions":{"1.0.0":{"name":"node-shared-cache","version":"1.0.0","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"*"},"devDependencies":{},"scripts":{"test":"node test","install":"node-gyp rebuild"},"repository":{"type":"git","url":"https://github.com/kyriosli/node-shared-cache.git"},"keywords":["Node.JS","LRU","Cache","Shared"],"author":{"name":"Kyrios"},"license":"ISC","gypfile":true,"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"0b0bc9c8cea0571c4f7014fa5c8a8802edfa5751","_id":"node-shared-cache@1.0.0","_shasum":"21ca73659599083cfcdc14f74ac3bc52efd425e1","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"dist":{"shasum":"21ca73659599083cfcdc14f74ac3bc52efd425e1","tarball":"https://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.0.0.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"directories":{}},"1.0.1":{"name":"node-shared-cache","version":"1.0.1","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"*"},"devDependencies":{},"scripts":{"test":"node test","install":"node-gyp rebuild"},"repository":{"type":"git","url":"https://github.com/kyriosli/node-shared-cache.git"},"keywords":["Node.JS","LRU","Cache","Shared"],"author":{"name":"Kyrios"},"license":"ISC","gypfile":true,"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"8b1209d5337fc53a4fde05eefabe8a3d1d0054b3","_id":"node-shared-cache@1.0.1","_shasum":"a6d41c07551394b71c2b6cdc16e02ec6395b83e0","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"dist":{"shasum":"a6d41c07551394b71c2b6cdc16e02ec6395b83e0","tarball":"https://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.0.1.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"directories":{}},"1.1.0":{"name":"node-shared-cache","version":"1.1.0","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"*"},"devDependencies":{},"scripts":{"test":"node test","install":"node-gyp rebuild"},"repository":{"type":"git","url":"https://github.com/kyriosli/node-shared-cache.git"},"keywords":["Node.JS","LRU","Cache","Shared"],"author":{"name":"Kyrios"},"license":"ISC","gypfile":true,"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"7a09e8c78e9bfd3056a18960770f905d486886b0","_id":"node-shared-cache@1.1.0","_shasum":"66fb084091c501690bb1db01af54a912e9a2ce76","_from":".","_npmVersion":"2.4.1","_nodeVersion":"1.1.0","_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"dist":{"shasum":"66fb084091c501690bb1db01af54a912e9a2ce76","tarball":"https://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.1.0.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"directories":{}},"1.2.0":{"name":"node-shared-cache","version":"1.2.0","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"~2.2.0"},"devDependencies":{},"scripts":{"test":"node test","install":"node-gyp rebuild"},"repository":{"type":"git","url":"git+https://github.com/kyriosli/node-shared-cache.git"},"keywords":["Node.JS","LRU","Cache","Shared"],"author":{"name":"Kyrios"},"license":"ISC","gypfile":true,"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"177a8e13d679e98bd1f2abc89f0a36a655aa6c32","_id":"node-shared-cache@1.2.0","_shasum":"0f0a4dfc0d0211d5452f2871b09d75c3e7dc746c","_from":".","_npmVersion":"3.3.9","_nodeVersion":"0.12.7","_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"dist":{"shasum":"0f0a4dfc0d0211d5452f2871b09d75c3e7dc746c","tarball":"https://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.2.0.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"_npmOperationalInternal":{"host":"packages-13-west.internal.npmjs.com","tmp":"tmp/node-shared-cache-1.2.0.tgz_1458029046804_0.623990947380662"},"directories":{}},"1.4.0":{"name":"node-shared-cache","version":"1.4.0","description":"Interprocess shared memory cache for Node.JS","main":"index.js","dependencies":{"nan":"~2.2.0"},"devDependencies":{},"scripts":{"test":"node test","install":"node-gyp rebuild"},"repository":{"type":"git","url":"git+https://github.com/kyriosli/node-shared-cache.git"},"keywords":["Node.JS","LRU","Cache","Shared"],"author":{"name":"Kyrios"},"license":"ISC","gypfile":true,"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"homepage":"https://github.com/kyriosli/node-shared-cache","gitHead":"d0612198165eb6a60bb0027f467340c24c2bc2d9","_id":"node-shared-cache@1.4.0","_shasum":"0701124df383f19f5434be5bf2a8a4764acf3b49","_from":".","_npmVersion":"3.3.9","_nodeVersion":"0.12.7","_npmUser":{"name":"kyriosli","email":"lz3259@gmail.com"},"dist":{"shasum":"0701124df383f19f5434be5bf2a8a4764acf3b49","tarball":"https://registry.npmjs.org/node-shared-cache/-/node-shared-cache-1.4.0.tgz"},"maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"_npmOperationalInternal":{"host":"packages-13-west.internal.npmjs.com","tmp":"tmp/node-shared-cache-1.4.0.tgz_1458181592675_0.051117148250341415"},"directories":{}}},"readme":"## node-shared-cache\r\n\r\nInterprocess shared memory cache for Node.JS\r\n\r\nIt supports auto memory-management and fast object serialization. It uses a hashmap and LRU cache internally to maintain its contents.\r\n\r\n## Install\r\n\r\nInstall `node-gyp` first if you do not have it installed:\r\n\r\n    sudo npm install node-gyp -g\r\n\r\nThen\r\n\r\n    npm install kyriosli/node-shared-cache\r\n\r\n\r\n## Terms of Use\r\n\r\nThis software (source code and its binary builds) is absolutely copy free and any download or modification is permitted except for unprohibited\r\ncommercial use.\r\n\r\nBut due to the complexity of this software, any bugs or runtime exceptions could happen when programs which includeed it run into an unexpected\r\nsituation, which in most cases should be harmless but also have the chance to cause:\r\n\r\n  - program crash\r\n  - system down\r\n  - software damage\r\n  - hardware damage\r\n\r\nwhich would lead to data corruption or even economic losses.\r\n\r\nSo when you are using this software, DO\r\n\r\n  - check the data\r\n  - double check the data\r\n  - avoid undefined behavior to happen\r\n\r\nTo avoid data crupption, we use a read-write lock to ensure that data modification is exclusive. But when a program is writting data when something\r\nbad, for example, a SIGKILL, happens that crashes the program before the write operation is complete and lock is released, other processes may not be\r\nable to enter the exclusive region again. I do not use an auto recovery lock such as `flock`, which will automatically release when process exits, just\r\nin case that wrong data is returned when performing a reading operation, or even, causing a segment fault.\r\n\r\n## usage\r\n\r\n```js\r\nvar cache = require('node-shared-cache');\r\nvar obj = new cache.Cache(\"test\", 557056);\r\n// setting property\r\nobj.foo = \"bar\";\r\n// getting property\r\nconsole.log(obj.foo);\r\n// enumerating properties\r\nfor(var k in obj);\r\nObject.keys(obj);\r\n// deleting property\r\ndelete obj.foo;\r\n// writing objects is also supported\r\nobj.foo = {'foo': 'bar'};\r\n// but original object reference is not saved\r\nvar test = obj.foo = {'foo': 'bar'};\r\ntest === obj.foo; // false\r\n// circular reference is supported.\r\ntest.self = test;\r\nobj.foo = test;\r\n// and saved result is also circular\r\ntest = obj.foo;\r\ntest.self === test; // true\r\n// release memory region\r\ncache.release(\"test\");\r\n// increase a key\r\ncache.increase(obj, \"foo\");\r\ncache.increase(obj, \"foo\", 3);\r\n// dump current cache\r\nvar values = cache.dump(obj);\r\n// dump current cache by key prefix\r\nvalues = cache.dump(obj, \"foo_\");\r\n\r\n```\r\n\r\n### class Cache\r\n\r\n#### constructor\r\n\r\n    function Cache(name, size, optional block_size)\r\n\r\n`name` represents a file name in shared memory, `size` represents memory size in bytes to be used. `block_size` denotes the size of the unit of the memory block.\r\n\r\n`block_size` can be any of:\r\n\r\n  - cache.SIZE_64 (6): 64 bytes (default)\r\n  - cache.SIZE_128 (7): 128 bytes\r\n  - cache.SIZE_256 (8): 256 bytes\r\n  - cache.SIZE_512 (9): 512 bytes\r\n  - cache.SIZE_1K (10): 1KB\r\n  - cache.SIZE_2K (11): 2KB\r\n  - ...\r\n  - cache.SIZE_16K (14): 16KB\r\n\r\nNote that:\r\n\r\n  - `size` should not be smaller than 524288 (512KB)\r\n  - block count is 32-aligned\r\n  - key length should not be greater than `(block_size - 32) / 2`, for example, when block size is 64 bytes, maximum key length is 16 chars.\r\n  - key length should also not be greater than 256\r\n\r\nSo when block_size is set to default, the maximum memory size that can be used is 128M, and the maximum keys that can be stored is 2088960 (8192 blocks is used for data structure)\r\n\r\n#### property setter\r\n\r\n    set(name, value)\r\n\r\n### exported methods\r\n\r\n#### release\r\n\r\n    function release(name)\r\n\r\nThe shared memory named `name` will be released. Throws error if shared memory is not found. Note that this method simply calls `shm_unlink` and does not check whether the memory region is really initiated by this module.\r\n\r\nDon't call this method when the cache is still used by some process, may cause memory leak\r\n\r\n#### clear\r\n\r\n    function clear(instance)\r\n\r\nClears a cache\r\n\r\n#### increase\r\n\r\n    function increase(instance, name, optional increase_by)\r\n\r\nIncrease a key in the cache by an integer (default to 1). If the key is absent, or not an integer, the key will be set to `increase_by`.\r\n\r\n#### dump\r\n\r\n    function dump(instance, optional prefix)\r\n\r\nDump keys and values \r\n\r\n## Performance\r\n\r\nTests are run under a virtual machine with one processor: \r\n\r\n    $ node -v\r\n    v0.12.4\r\n    $ cat /proc/cpuinfo\r\n    processor   : 0\r\n    vendor_id   : GenuineIntel\r\n    cpu family  : 6\r\n    model       : 45\r\n    model name  : Intel(R) Xeon(R) CPU E5-2630 0 @ 2.30GHz\r\n    stepping    : 7\r\n    microcode   : 0x70d\r\n    cpu MHz     : 2300.090\r\n    cache size  : 15360 KB    \r\n    ...\r\n\r\nBlock size is set to 64 and 1MB of memory is used.\r\n\r\n### Setting property\r\n\r\nWhen setting property 100w times:\r\n\r\n```js\r\n// test plain object\r\nvar plain = {};\r\nconsole.time('plain obj');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['test' + (i & 127)] = i;\r\n}\r\nconsole.timeEnd('plain obj');\r\n\r\n// test shared cache\r\nvar obj = new binding.Cache(\"test\", 1048576);\r\nconsole.time('shared cache');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['test' + (i & 127)] = i;\r\n}\r\nconsole.timeEnd('shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    plain obj: 227ms\r\n    shared cache: 492ms (1:2.17)\r\n\r\n### Getting property\r\n\r\nWhen trying to read existing key:\r\n\r\n```js\r\nconsole.time('read plain obj');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['test' + (i & 127)];\r\n}\r\nconsole.timeEnd('read plain obj');\r\n\r\nconsole.time('read shared cache');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['test' + (i & 127)];\r\n}\r\nconsole.timeEnd('read shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    read plain obj: 138ms\r\n    read shared cache: 524ms (1:3.80)\r\n\r\nWhen trying to read keys that are not existed:\r\n\r\n```js\r\nconsole.time('read plain obj with key absent');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    plain['oops' + (i & 127)];\r\n}\r\nconsole.timeEnd('read plain obj with key absent');\r\n\r\nconsole.time('read shared cache with key absent');\r\nfor(var i = 0; i < 1000000; i++) {\r\n    obj['oops' + (i & 127)];\r\n}\r\nconsole.timeEnd('read shared cache with key absent');\r\n```\r\n\r\nThe result is:\r\n\r\n    read plain obj with key absent: 265ms\r\n    read shared cache with key absent: 595ms (1:2.24)\r\n\r\n### Enumerating properties\r\n\r\nWhen enumerating all the keys:\r\n\r\n```js\r\nconsole.time('enumerate plain obj');\r\nfor(var i = 0; i < 100000; i++) {\r\n    Object.keys(plain);\r\n}\r\nconsole.timeEnd('enumerate plain obj');\r\n\r\nconsole.time('enumerate shared cache');\r\nfor(var i = 0; i < 100000; i++) {\r\n    Object.keys(obj);\r\n}\r\nconsole.timeEnd('enumerate shared cache');\r\n```\r\n\r\nThe result is:\r\n\r\n    enumerate plain obj: 1201ms\r\n    enumerate shared cache: 4262ms (1:3.55)\r\n\r\nWarn: Because the shared memory can be modified at any time even the current Node.js\r\nprocess is running, depending on keys enumeration result to determine whether a key\r\nis cached is unwise. On the other hand, it takes so long a time to build strings from\r\nmemory slice, as well as putting them into an array, so DO NOT USE IT unless you know\r\nthat what you are doing.\r\n\r\n### Object serialization\r\n\r\nWe choose a c-style binary serialization method rather than `JSON.stringify`, in two\r\nconcepts:\r\n\r\n  - Performance serializing and unserializing\r\n  - Support for circular reference\r\n\r\nTests code list:\r\n\r\n```js\r\nvar input = {env: process.env, arr: [process.env, process.env]};\r\nconsole.time('JSON.stringify');\r\nfor(var i = 0; i < 100000; i++) {\r\n    JSON.stringify(input);\r\n}\r\nconsole.timeEnd('JSON.stringify');\r\n\r\nconsole.time('binary serialization');\r\nfor(var i = 0; i < 100000; i++) {\r\n    obj.test = input;\r\n}\r\nconsole.timeEnd('binary serialization');\r\n\r\n// test object unserialization\r\ninput = JSON.stringify(input);\r\nconsole.time('JSON.parse');\r\nfor(var i = 0; i < 100000; i++) {\r\n    JSON.parse(input);\r\n}\r\nconsole.timeEnd('JSON.parse');\r\n\r\nconsole.time('binary unserialization');\r\nfor(var i = 0; i < 100000; i++) {\r\n    obj.test;\r\n}\r\nconsole.timeEnd('binary unserialization');\r\n```\r\n\r\nThe result is:\r\n\r\n    JSON.stringify: 5876ms\r\n    binary serialization: 2523ms (2.33:1)\r\n    JSON.parse: 2042ms\r\n    binary unserialization: 2098ms (1:1.03)\r\n\r\n\r\n## TODO\r\n\r\n  - add dead-lock auto recovery when data is inconsistent\r\n","maintainers":[{"name":"kyriosli","email":"lz3259@gmail.com"}],"time":{"modified":"2016-03-17T02:26:33.224Z","created":"2015-06-08T08:07:21.938Z","1.0.0":"2015-06-08T08:07:21.938Z","1.0.1":"2015-06-17T08:16:34.417Z","1.1.0":"2015-06-18T11:12:56.320Z","1.2.0":"2016-03-15T08:04:07.375Z","1.3.0":"2016-03-17T02:24:19.902Z","1.4.0":"2016-03-17T02:26:33.224Z"},"homepage":"https://github.com/kyriosli/node-shared-cache","keywords":["Node.JS","LRU","Cache","Shared"],"repository":{"type":"git","url":"git+https://github.com/kyriosli/node-shared-cache.git"},"author":{"name":"Kyrios"},"bugs":{"url":"https://github.com/kyriosli/node-shared-cache/issues"},"license":"ISC","readmeFilename":"README.md","users":{"satans17":true},"_attachments":{},"_etag":"\"8MHEYDYEFNJVBGP5RUG6EW36M\""}